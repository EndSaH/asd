<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[莫比乌斯反演习题总结]]></title>
    <url>%2Fposts%2F52976%2F</url>
    <content type="text"><![CDATA[Foreword题目 + 题解 $(i, j) \Longleftrightarrow \gcd (i, j)$ [SDOI2017] 数字表格Description $$T \le 10 ^3, 1 \le n, m \le 10 ^6$$ Solution不妨设 $n \le m$$$\begin{aligned}&amp; \prod _{i = 1} ^n \prod _{j = 1} ^m f((i, j)) \\=&amp; \prod _{d = 1} ^n \prod _{i = 1} ^n \prod _{j = 1} ^m [(i, j) = d] f(d) \\=&amp; \prod _{d = 1} ^n f(d) ^{\sum _{i = 1} ^n \sum _{j = 1} ^m [(i, j) = d]} \\\end{aligned}$$指数部分提出来 单独计算$$\begin{aligned}&amp; \sum _{i = 1} ^n \sum _{j = 1} ^m [(i, j) = d] \\=&amp; \sum _{i = 1} ^{\lfloor \frac n d \rfloor} \sum _{j = 1} ^{\lfloor \frac m d \rfloor} [(i, j) = 1] \\=&amp; \sum _{i = 1} ^{\lfloor \frac n d \rfloor} \sum _{j = 1} ^{\lfloor \frac m d \rfloor} \sum _{x | (i, j)} \mu (x) \\=&amp; \sum _{x = 1} ^{\lfloor \frac n d \rfloor} \mu (x) \lfloor \frac n {dx} \rfloor \lfloor \frac m {dx} \rfloor\end{aligned}$$ 考虑先枚举 $dx$ 的乘积再枚举 $d$ ，可以证明这样得出的答案不变（简易理解就是可以遍历到所有可能的 $d, x$ 的取值集合，不重不漏） 这应该也算是一种套路了 令 $T = dx$ ，$x$ 可用 $\frac T d$ 代替$$\begin{aligned}&amp; \prod _{T = 1} ^n \prod _{d | T} f(d) ^{\mu (\frac T d) \lfloor \frac n T \rfloor \lfloor \frac m T \rfloor} \\=&amp; \prod _{T = 1} ^n \left( \prod _{d | T} f(d) ^{\mu (\frac T d) } \right) ^{ \lfloor \frac n T \rfloor \lfloor \frac m T \rfloor}\end{aligned}$$预处理 斐波那契数列及其逆元 和 里面东西的前缀积，筛出 $\mu$ 之后直接枚举每个数对其倍数算贡献，复杂度 $\cal O(n (\ln n + \log))$ （ $\log$ 是快速幂带的复杂度，这里 $\mu$ 只有三种取值，预处理逆元后就不需要快速幂了） 每次询问数论分块 + 快速幂，复杂度 $\cal O(T (\sqrt n + \sqrt m) \log)$ ，其中 $\cal T$ 是数据组数（注意逆元） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-05-31 21:11 * FileName : SDOI2017_shuzibiaoge.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;bitset&gt;typedef long long LL;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21 | 1)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 1e6 + 2;const int mod = 1e9 + 7;int T, n, m;int mu[maxN], fib[maxN], fibinv[maxN], F[maxN];std::bitset&lt;maxN&gt; vis;std::vector&lt;int&gt; prim;inline void Mod(int&amp; x)&#123; x &gt;= mod ? x -= mod : 0; &#125;inline int QP(int a, LL n)&#123; if (n == -1) return QP(a, mod - 2); if (a == 1) return 1; register int res = 1; while (n) &#123; if (n &amp; 1) res = (LL)res * a % mod; a = (LL)a * a % mod; n &gt;&gt;= 1; &#125; return res;&#125;inline void Pre(int n)&#123; fib[1] = fibinv[1] = mu[1] = F[1] = F[0] = 1; for (register int i = 2; i &lt;= n; ++i) &#123; F[i] = 1, Mod(fib[i] = fib[i - 1] + fib[i - 2]); fibinv[i] = QP(fib[i], -1); if (!vis[i]) prim.push_back(i), mu[i] = -1; for (register auto j : prim) &#123; if (i * j &gt; n) break; vis.set(i * j); if (i % j) mu[i * j] = -mu[i]; else break; &#125; &#125; for (register int i = 1; i &lt;= n; ++i) for (register int j = 1; i * j &lt;= n; ++j) if (~mu[j]) &#123; if (mu[j]) F[i * j] = (LL)F[i * j] * fib[i] % mod; &#125; else F[i * j] = (LL)F[i * j] * fibinv[i] % mod; for (register int i = 2; i &lt;= n; ++i) F[i] = (LL)F[i] * F[i - 1] % mod;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("SDOI2017_shuzibiaoge.in", "r", stdin); freopen("SDOI2017_shuzibiaoge.out", "w", stdout);#endif Pre(maxN - 2); T = read(); while (T--) &#123; n = read(), m = read(); if (n &gt; m) std::swap(n, m); register int ans = 1; for (register int l = 1, r; l &lt;= n; l = r + 1) &#123; r = std::min(n / (n / l), m / (m / l)); ans = (LL)ans * QP( (LL)F[r] * QP(F[l - 1], -1) % mod, (LL)(n / l) * (m / l) ) % mod; &#125; write(ans), putchar('\n'); &#125; return 0;&#125; [SDOI2014] 数表Description求$$\sum _{i = 1} ^n \sum _{j = 1} ^m [\sigma _1 ((i, j)) \le a] \sigma _1 ((i, j)) \\T \le 2 \times 10 ^4, 1 \le n, m \le 10 ^5, a \le 10 ^9$$每组数据有不同的 $a$ Solution不妨设 $n \le m$ 先考虑去掉 $\le a$ 的限制怎么做 可以知道 $\sigma _1 ((i, j)) = \sum \limits _{x | (i, j)} x$ ，于是不需要反演，可以直接这样推：$$\begin{aligned}&amp; \sum _{i = 1} ^n \sum _{j = 1} ^m \sigma _1 ((i, j)) \\=&amp; \sum _{i = 1} ^n \sum _{j = 1} ^m \sum _{x | (i, j)} x \\=&amp; \sum _{x = 1} ^n x \lfloor \frac n x \rfloor \lfloor \frac m x \rfloor\end{aligned}$$然后就无路可走了 于是找另一条路走：$$\begin{aligned}&amp; \sum _{i = 1} ^n \sum _{j = 1} ^m \sigma _1 ((i, j)) \\=&amp; \sum _{d = 1} ^n \sigma _1 (d) \sum _{i = 1} ^n \sum _{j = 1} ^m [(i, j) = d] \\=&amp; \sum _{d = 1} ^n \sigma _1 (d) \sum _{x = 1} ^{\lfloor \frac n d \rfloor} \mu (x) \lfloor \frac n {dx} \rfloor \lfloor \frac m {dx} \rfloor\end{aligned}$$（第二行最后那块实在是太常见了，就直接变了） 依然枚举 $T = dx$ 变为最终式：$$\sum _{T = 1} ^n \lfloor \frac n T \rfloor \lfloor \frac m T \rfloor \sum _{d | T} \sigma _1 (d) \mu (\frac T d)$$再回到题目的 $\le a$ 的限制 惊喜的发现这个式子让这个题目变得可做了 将后面这一块单独提出来看：令 $g(T) = \sum \limits _{d | T} \sigma _1 (d) \mu (\frac T d)$ 我们一开始枚举的 $d$ 的意义就是 $i, j$ 的 $\gcd$ ，中间就算经过了变换，它的意义依然没有改变；也就是说，$\sigma _1 ((i, j)) \le a$ 也对应着上面 $g(T)$ 中所枚举的 $d$ 需要满足 $\sigma _1 (d) \le a$ 于是我们离线将 $a$ 排序，同时将 $10 ^5$ 内的数线性筛出其约数和并按约数和排序 每次询问将满足约数和小于 $a$ 的数对其倍数算贡献，也就是动态的更新 $g(T)$ ，考虑到整除分块时需要查询前缀和，而修改只需要单点加，于是便用树状数组动态维护 $g(T)$ 对 $2 ^{31} - 1$ 取模，只需要算的时候用 unsigned int ，将答案再与 $2 ^{31}$ 相与即可（注意 (1 &lt;&lt; 31) - 1 此处会爆 int ，因为 $2 ^{31}$ 超出了 int 范围，故用 0x7FFFFFFF 为宜） 复杂度的话，视作 $n, m$ 同阶，一开始排序和线性筛即为 $\cal O(T \log T + n \log n)$ ，因为对约数和和询问排了序；处理询问时，修改处枚举倍数和树状数组有两个 $\log$ （其中有一个是 $\ln$ ，粗略算成 $\log$ 算了），回答用到整除分块和树状数组，综上，复杂度约为 $\cal O(T \sqrt n \log n + n \log ^2 n + T \log T)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-06-04 19:13 * FileName : SDOI2014_number.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;typedef std::pair&lt;int, int&gt; pii;typedef unsigned int uint;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21 | 1)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 1e5;const int maxQ = 2e4;int T;int ans[maxN + 2], low[maxN + 2], mu[maxN + 2];uint BIT[maxN + 2];std::bitset&lt;maxN + 2&gt; vis;std::vector&lt;int&gt; prim;pii sigma[maxN + 2];struct Ask&#123; int id, n, m, a; Ask() &#123; &#125; Ask(int id, int n, int m, int a) : id(id), n(n), m(m), a(a) &#123; &#125; bool operator&lt;(const Ask&amp; x) const &#123; return a &lt; x.a; &#125;&#125; ask[maxQ + 2];inline void Add(int x, int addval)&#123; while (x &lt;= maxN) BIT[x] += addval, x += x &amp; -x;&#125;inline uint Query(int x)&#123; register uint res = 0; while (x) res += BIT[x], x -= x &amp; -x; return res;&#125;inline void Shuffle(int n)&#123; prim.reserve(n / log(n)); sigma[1] = pii(1, 1), mu[1] = low[1] = 1; for (register int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) &#123; prim.push_back(i); mu[i] = -1, low[i] = i, sigma[i] = pii(i + 1, i); &#125; for (register auto j : prim) &#123; if (i * j &gt; n) break; vis.set(i * j); if (i % j) low[i * j] = j, mu[i * j] = -mu[i], sigma[i * j] = pii(sigma[i].first * sigma[j].first, i * j); else &#123; low[i * j] = low[i] * j; if (low[i] == i) sigma[i * j] = pii(sigma[i].first + i * j, i * j); else sigma[i * j] = pii(sigma[i / low[i]].first * sigma[j * low[i]].first, i * j); break; &#125; &#125; &#125; std::sort(sigma + 1, sigma + n + 1);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("SDOI2014_number.in", "r", stdin); freopen("SDOI2014_number.out", "w", stdout);#endif Shuffle(maxN); T = read(); for (register int i = 1, n, m, a; i &lt;= T; ++i) &#123; n = read(), m = read(), a = read(); if (n &gt; m) std::swap(n, m); ask[i] = Ask(i, n, m, a); &#125; std::sort(ask + 1, ask + T + 1); register pii* j = sigma + 1; for (register Ask* p = ask + 1; p - ask &lt;= T; ++p) &#123; while (j - sigma &lt;= maxN and j-&gt;first &lt;= p-&gt;a) &#123; for (register int k = 1; k * j-&gt;second &lt;= maxN; ++k) Add(k * j-&gt;second, j-&gt;first * mu[k]); ++j; &#125; uint cans = 0; for (register int l = 1, r; l &lt;= p-&gt;n; l = r + 1) &#123; r = std::min(p-&gt;n / (p-&gt;n / l), p-&gt;m / (p-&gt;m / l)); cans += (uint)(p-&gt;n / l) * (p-&gt;m / l) * (Query(r) - Query(l - 1)); &#125; ans[p-&gt;id] = cans &amp; 0x7FFFFFFF; &#125; for (register int i = 1; i &lt;= T; ++i) write(ans[i]), putchar('\n'); return 0;&#125; To be continued]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1138E]Museums Tour]]></title>
    <url>%2Fposts%2F32916%2F</url>
    <content type="text"><![CDATA[前言题面传送门 题意给定一个 $n$ 个点 $m$ 条边的有向图（无重边自环），定义一次周期为 $d$ 天。 现在你会在一个周期的第一天从 $1$ 号点开始行走，每经过一条边，就会花费一天时间；你不能在一个点逗留不走，但是所有点你都可以重复经过。 每个点在一个周期中，会有部分时间开放，而其他时间不开放；注意，不开放不意味着你不能走到这个点。 （举个例子，10100 表示一个周期的第一天和第三天开放，$2, 4, 5$ 天不开放） 求你能访问到的最多的位于开放时间的点（同样的点只算一次）。 $n, m \le 10^5, d \le 50$ 题解这题比较套路… 没有灵光一闪的话是根本想不到的… 首先可以发现强连通分量里面是可以乱走一通的，还是有向图，看数据范围也像是 $\cal O(nd)$，基本可以确定是缩点成 $\rm{DAG}$ 后 $\rm{DP}$ 了 但是那个天数不太好处理，缩成点之后以多少天进去可以转换成很多不同的出来的天数，对答案产生的贡献也不同，不加处理的话 $\rm{DP}$ 状态怎么设都是个很大的问题 你会发现 $\rm{DAG + DP}$ 这条路已经差不多走死了，只能往建模上想了 再仔细观察 $d$… $50$ 的数据范围大有用意啊 这种直接建图再处理特别复杂的，如果你对于这个 $d$ 的范围再敏感一点，你就会马上反应出一个名词： 分层图！ 估计这一个词就可以点醒所有人了。 天数难以表示？那就换个建模方式，用图上的信息来表示！ 具体而言，现在我们将一个点 $u$ 拆作 $d$ 个点 $u_{1, \dots , d}$，第 $i$ 个点表示第 $i$ 天位于 $u$ 点；对于原来的一条有向边 $(u, v)$，这样重新连边：$u_1 \longrightarrow v_2, u_2 \longrightarrow v_3, \cdots, u_d \longrightarrow v_1$ 若点 $u$ 在第 $i$ 天开放，那么 $u_i$ 点权为 $1$；否则其点权为 $0$。 又有一个小问题：不会算重吗？ 实际上，只有当被拆出来的点在同一个强连通分量中，才会算重，这时候就只需要加一次就可以了； 如果不在，就不会有重复的点权计入答案（想想为什么） 显然可以证明，若 $u _i$ 到 $u _{i’}$ 有一条路径，那么 $u _{i’}$ 到 $u _i$ 也必定有一条路径 也就是说，拆出来的点在一个强连通分量内，就需要去重；不在的话，他们之间必定没有路径可达，肯定不会再重复统计。 然后问题就变为了：求从 $1$ 号点出发的一条点权最大的路径。 缩点成 $\rm DAG\ DP$ 即可（这里我用的是记忆化搜索，建反图拓扑排序也可以）。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-03-31 11:27 * FileName : CF1138.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 5e6 + 2;const int maxD = 52;int n, m, d, dfst, colcnt, top;char opt;int stk[maxN], dfn[maxN], low[maxN], col[maxN], sum[maxN], F[maxN];int head[2][maxN];struct Chain&#123; int v, next; &#125;chain[2][maxN];inline void Link(int u, int v)&#123; static int ecnt = 0; chain[0][++ecnt] = (Chain)&#123;v, head[0][u]&#125;; head[0][u] = ecnt;&#125;inline void Newlink(int u, int v)&#123; static int ecnt = 0; chain[1][++ecnt] = (Chain)&#123;v, head[1][u]&#125;; head[1][u] = ecnt;&#125;void Tarjan(int u)&#123; dfn[u] = low[u] = ++dfst, stk[++top] = u; for (int i = head[0][u], v; i; i = chain[0][i].next) &#123; v = chain[0][i].v; if (!dfn[v]) Tarjan(v), Chkmin(low[u], low[v]); else if (!col[v]) Chkmin(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; col[u] = ++colcnt; while (stk[top] != u) col[stk[top--]] = colcnt; --top; &#125;&#125;int DFS(int u)&#123; if (F[u]) return F[u]; for (int i = head[1][u]; i; i = chain[1][i].next) Chkmax(F[u], DFS(chain[1][i].v)); return F[u] += sum[u];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("CF1138E.in", "r", stdin); freopen("CF1138E.out", "w", stdout);#endif n = read(), m = read(), d = read(); while (m--) &#123; int u = read(), v = read(); for (register int i = 1; i &lt; d; ++i) Link(u + (i - 1) * n, v + i * n); Link(u + (d - 1) * n, v); &#125; for (register int i = 1; i &lt;= n * d; ++i) if (!dfn[i]) Tarjan(i); for (register int i = 1; i &lt;= n * d; ++i) for (register int v, j = head[0][i]; j; j = chain[0][j].next) if (col[i] != col[v = chain[0][j].v]) Newlink(col[i], col[v]); for (register int i = 1; i &lt;= n; ++i) &#123; for (register int j = 0; j &lt; d; ++j) &#123; while (isspace(opt = getchar())); if ((opt &amp; 1) and F[col[i + j * n]] != i) F[col[i + j * n]] = i, ++sum[col[i + j * n]]; &#125; &#125; memset(F + 1, 0, colcnt * sizeof(int)); write(DFS(col[1])); return 0;&#125; Thanks for your consideration!]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>分层图</tag>
        <tag>DAG</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2004]文本编辑器]]></title>
    <url>%2Fposts%2F21003%2F</url>
    <content type="text"><![CDATA[前言题面传送门 本篇题解提供两种解法：暴力和块状链表。 重点不在这里，而在于： 全部用 $\text{STL}$ 实现。 另附上一个网站：cppreference.com，在对于语言和 $\text{STL}$ 的操作有疑问或者忘记了，可以去这里查。 众所周知，虽然 $\text{STL}$ 在不开 $O_2$ 的情况下效率欠佳，但是封装好的各类操作使得其代码复杂度极低，易于调试。 题解暴力首先，要对std::vector各项基本操作有所了解。 题目中所给的 6 个操作，都可以直观的用std::vector实现。 std::vector有两个成员函数：erase和insert。 std::vector.insert() std::vector.erase() 看到里面的插入区间和区间删除没？ 实际上，插入和删除的最坏复杂度是 $O(n)$ 的（一直在头部插删），这也就是说它暴力的原因。 具体细节（边界问题等），详见暴力代码。 块状链表就是块内是数组，每个块之间用链表连接的数据结构。 链表插入 $O(1)$，访问 $O(n)$；数组插入 $O(n)$，访问 $O(1)$。 块状链表，正是一个中间产物，都是 $O(\sqrt n)$。 这里只是小小的介绍一下概念，具体的应该有 $\text{dalao}$ 的题解写得比我更好，不再献丑。 链表套数组？还要动态？ std::list套std::vector啊！ 什么麻烦的回收内存，整段后移数组操作，有了封装好的函数，还怕什么？ 在这里，鬼迷心窍的我莫名奇妙地选择了std::forward_list作为std::list的替代品，因为std::forward_list是单向链表而std::list是双向，也许会快一些emmm（也许…. （顺带警告：不是 $\text{C++11}$ 会 $\text{CE}$） 放上几个要用的std::forward_list的成员函数，自己去 cppreference 看去： insert_after(), erase_after(), before_begin() 其他细节和边界处理其实也挺多的，具体看块状链表代码。 如果你不想用std::forward_list而想用std::list，这里有另一份代码。 总结关于 $\text{STL}$，一定要记住： 左闭右开！！！左闭右开！！！左闭右开！！！ 其实你要是认真的写了代码并推了边界条件，你就会发现左闭右开，下标从 $0$ 开始是一个多么友好的东西。 我的代码里根本就没有什么+1-1，边界条件需要想想，但是实际上你可以按直觉一遍打过去，基本不会错。这也是 $\text{STL}$ 的优越之处。 顺便说一句，隔壁加强版（带翻转操作）[AHOI2006]文本编辑器用std::vector实现的暴力是最优解2333333（翻转直接std::reverse） 大概就讲到这里吧- - Thanks for your consideration!]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF446C]DZY Loves Fibnacci Numbers]]></title>
    <url>%2Fposts%2F42251%2F</url>
    <content type="text"><![CDATA[$\text{Description}$给定数列 $a_1,a_2,\cdots,a_n$. 需要支持两种操作: 1 l r: 对 $l$ 到 $r$ 的每个数 $a_i$ 加上 $Fib_{i - l + 1}$. 2 l r: 询问区间 $l$ 到 $r$ 的和. $Fib$ 即斐波那契数列, 此处 $Fib_1 = Fib_2 = 1$. $n \le 3 \ast 10^5$, 答案对 $10^9 + 9$ 取模. $\text{Solution}$对于这种区间修改和区间求和, 首先想到线段树. 但是该如何打标记, 这才是最关键的问题. 单单是维护区间和挺简单的: 对于一个修改操作, 记录 $Fib$ 数列的前缀和, 每次对应的加上就可以了. 具体来说, 设当前需要修改的线段树节点对应区间为 $[l, r]$, 修改区间为 $[L, R]$ (显然, $[l, r] \subseteqq [L, R]$) 那么当前区间应该加上的值是: $sum_{r - L + 1} - sum_{l - L}$ $sum$ 表示 $Fib$ 数列的前缀和. Pushdown操作同理, 只不过是 $L=l, R=r$. 但这么做有个问题: 如何快速合并标记呢? 我可能是那个头最铁的人, 想到这个思路直接开打, 直接不合并标记, 而是用一个std::stack存放所有标记, Pushdown再一个个下放… 可想而知这样的程序效率是多低, $5 \ast 10^4$ 的数据都跑了 $\text{3s}$ … 那么, 我们是时候稍微转变一下标记的维护思路了. 在此之前, 你需要先了解广义斐波那契数列. 通俗的来讲, 就是把 $Fib$ 数列的第一项和第二项变为 $a$ 和 $b$, 而不再是固定的 $1,1$. 它有一些非常优美的性质: $$\sum_{i = 1}^nS_i=S_{n+2}-S_2$$$$S_i=bFib_{i - 1}+aFib_{i - 2}$$ $S$ 即为广义 $Fib$ 数列, $S_1 = a, S_2 = b$. 证明? 自己想去 于是考虑记录广义 $Fib$ 数列的前两项作为懒标记. 为什么? 因为这样就可以快速合并了! 要合并(对应数各自相加)两个广义 $Fib$ 数列, 只需要将 $a$ 和 $b$ 各自相加即可. 上面这句话请着重注意! 证明是不存在的 因为它的这些性质, 那么合并标记, 快速求和等等一系列问题, 我们已经全部解决了. 接下来, 就是恶心的各类细节操作了- - 详见代码. 重点看几个函数: Add, Pushdown, Change中return部分. $\text{Thank you for your consideration!}$]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT简洁笔记]]></title>
    <url>%2Fposts%2F41766%2F</url>
    <content type="text"><![CDATA[前言主要学自 Menci 的博客 不讲 $\text{FFT}$，这里只是讲一些其他的东西以及一些例题 定义相关多项式乘法本质$$C _i = \sum _{j = 0} ^i A _j B _{i - j}$$ 其中 $A, B, C$ 表示多项式的系数集合，$i$ 表示为第 $i$ 次项。 若没有第 $i$ 次项，系数视为 $0$。 复数乘法$$\begin{aligned}&amp; (a + bi)(c + di) \\=&amp; ac + adi + bci + bdi^2 \\=&amp; ac + (ad + bc)i - bd \\=&amp; (ac - bd) + (ad + bc)i\end{aligned}$$ 单位根$$\omega _n ^k = \cos (\frac{2 k \pi} n) + \sin (\frac{2 k \pi} n)i \\\text{(From: } e^{xi} = \cos x + \sin x i \text{)}$$ 两个性质$$\begin{aligned}\omega ^{2k} _{2n} &amp;= \cos (\frac{4 k \pi} {2n}) + \sin (\frac{4 k \pi} {2n})i \\&amp;= \cos (\frac{2 k \pi} n) + \sin(\frac{2 k \pi} n)i \\&amp;= \omega ^k _n \\\omega ^{k + \frac n 2} _n &amp;= \cos (\frac{2 (k + \frac n 2) \pi} n) + \sin (\frac{2 (k + \frac n 2) \pi} n)i \\&amp;= \cos (\frac{2 k \pi + n \pi} n) + \sin (\frac{2 k \pi + n \pi} n)i \\&amp;= -\cos (\frac{2 k \pi} n) + -\sin (\frac{2 k \pi} n)i \\&amp;= -\omega _n ^k\end{aligned}$$ 过程图 （其中求值和插值朴素算法均为 $\mathcal O(n^2)$，用 $\text{FFT}$ 优化后为 $\mathcal O(n \log n)$） 代码实现注意：$n$ 为 $2$ 的方幂。 递归比较慢，考虑如何迭代。 雷德算法发现在分治到底划分完毕后，每个数刚好位于其二进制翻转后的位置： 123456000 001 010 011 100 101 110 111 0 1 2 3 4 5 6 7 0 2 4 6 - 1 3 5 7 0 4 - 2 6 - 1 5 - 3 7 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7000 100 010 110 001 101 011 111 于是有了如下代码（很抱歉，我并不知道如何证明正确性）： 12345678for (lim = 1, l = 0; lim &lt;= n + m; lim &lt;&lt;= 1, ++l);for (register int i = 0; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (l - 1); // mind the priority of operation// when calculate *a:for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); 这种倒序位实现迭代 $\text{FFT}$ 的算法称为雷德算法。 于是便可以迭代求解： 1234567891011121314151617inline void DFT(Comp* a, int n, int flag) // Comp: Complex&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (register int nn = 2, m; nn &lt;= n; nn &lt;&lt;= 1) // nn: the length &#123; m = nn &gt;&gt; 1; for (register Comp* curr = a; curr != a + n; curr += nn) // combining the A_1 and A_2 for (register int i = 0; i &lt; m; ++i) &#123; static Comp tmp; tmp = Omega(nn, flag * i) * curr[i + m]; // attention! curr[i + m] = curr[i] - tmp, curr[i] += tmp; &#125; &#125;&#125; 注意到中间的这段代码： 12tmp = Omega(nn, flag * i) * curr[i + m];curr[i + m] = curr[i] - tmp, curr[i] += tmp; 其中 flag 表示其为 $\text{DFT}$ ( 1 ) 还是 $\text{IDFT}$ ( -1 )。 假设现在正在进行 $\text{DFT}$，那么代码抽出来看就是： $$\begin{aligned}t &amp;\gets \omega _n ^k \times a _{k + \frac n 2} \\a _{k + \frac n 2} &amp;\gets a_k - t \\a _k &amp;\gets a_k + t\end{aligned}$$ 省去了之前需要复制数组的麻烦。 这一过程被称为蝴蝶操作。 例题【模板】多项式乘法略。 我跑了大概 5000ms…慢的很 部分代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const int maxN = 1 &lt;&lt; 21 | 1;const double pi = acos(-1);int n, m, lim, l;int rev[maxN];struct Comp&#123; double real, imag; Comp() &#123; &#125; Comp(double real, double imag) : real(real), imag(imag) &#123; &#125; Comp operator-(const Comp&amp; x) const &#123; return Comp(real - x.real, imag - x.imag); &#125; Comp operator+(const Comp&amp; x) const &#123; return Comp(real + x.real, imag + x.imag); &#125; Comp&amp; operator+=(const Comp&amp; x) &#123; *this = *this + x; return *this; &#125; Comp operator*(const Comp&amp; x) const &#123; return Comp(real * x.real - imag * x.imag, real * x.imag + imag * x.real); &#125; Comp&amp; operator*=(const Comp&amp; x) &#123; *this = *this * x; return *this; &#125;&#125; a[maxN], b[maxN];inline Comp Omega(int n, int k)&#123; return Comp(cos((k &lt;&lt; 1) * pi / n), sin((k &lt;&lt; 1) * pi / n)); &#125;inline void DFT(Comp* a, int n, int flag)&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (register int nn = 2, m; nn &lt;= n; nn &lt;&lt;= 1) &#123; m = nn &gt;&gt; 1; for (register Comp* curr = a; curr != a + n; curr += nn) for (register int i = 0; i &lt; m; ++i) &#123; static Comp tmp; tmp = Omega(nn, flag * i) * curr[i + m]; curr[i + m] = curr[i] - tmp, curr[i] += tmp; &#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("LGP3803.in", "r", stdin); freopen("LGP3803.out", "w", stdout);#endif n = read(), m = read(); for (register int i = 0; i &lt;= n; ++i) a[i] = Comp(read(), 0); for (register int i = 0; i &lt;= m; ++i) b[i] = Comp(read(), 0); for (lim = 1, l = 0; lim &lt;= n + m; lim &lt;&lt;= 1, ++l); for (register int i = 0; i &lt; lim; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (l - 1); DFT(a, lim, 1), DFT(b, lim, 1); for (register int i = 0; i &lt; lim; ++i) a[i] *= b[i]; DFT(a, lim, -1); for (register int i = 0; i &lt;= n + m; ++i) write(int(a[i].real / lim + 0.5)), putchar(' '); return 0;&#125; [ZJOI2014]力题意自己看，特别清晰明了 题解省选考裸题了解一下 设下标从 $0$ 开始。 颓柿子： 首先，$E_j$ 的表达式： $$E_j = \frac { \sum\limits _{i = 0} ^ {j - 1} \frac {q_i q_j} {(i - j)^2} - \sum\limits _{i = j + 1} ^ {n - 1} \frac {q_i q_j} {(i - j)^2} } {q_j}$$ 上下同时约去 $q_j$： $$\begin{aligned}E_j&amp;= \frac { \sum\limits _{i = 0} ^ {j - 1} \frac {q_i q_j} {(i - j)^2} - \sum\limits _{i = j + 1} ^ {n - 1} \frac {q_i q_j} {(i - j)^2} } {q_j} \\&amp;= \sum _{i = 0} ^{j - 1} \frac {q_i} {(i - j)^2} - \sum _{i = j + 1} ^{n - 1} \frac {q_i} {(i - j)^2}\end{aligned}$$ 令 $g_i = \frac 1 {i ^ 2}$，特别地，$g_0 = 0$。显然其为偶函数。 则上式可以变为： $$\begin{aligned}E_j&amp;= \sum _{i = 0} ^{j - 1} \frac {q_i} {(i - j)^2} - \sum _{i = j + 1} ^{n - 1} \frac {q_i} {(i - j)^2} \\&amp;= \sum _{i = 0} ^{j} {q_i} g _{j - i} - \sum _{i = j} ^{n - 1} {q_i} g _{i - j}\end{aligned}$$ （$j - 1$ 变为 $j$ 是为了形式变得和多项式乘法一样，实际上 $j = i$ 时因 $g_0 = 0$ 不会对答案产生贡献才不是我打错了） 回忆下开头说的多项式乘法本质，可以发现减号前面的式子就是卷积形式了；至于后面，可以用一张图来感性理解： （来自GoldenPotato dalao的博客） 如果要理性理解的话，请继续看： 考虑将 $q$ 反向变为 $q’$，即令 $q’ _{n - i - 1} = q _i$。 将减号两边拆开算，即令 $A_j = \sum\limits _{i = 0} ^{j} {q_i} g _{j - i}, B_j = \sum\limits _{i = j} ^{n - 1} {q_i} g _{i - j}$。 考虑单独计算 $B_j$，此时用 $q’$ 代替 $q$： $$\begin{aligned}B_j&amp;= \sum _{i = j} ^{n - 1} {q_i} g _{i - j} \\&amp;= \sum _{i = j} ^{n - 1} {q’ _{n - i - 1}} g _{i - j}\end{aligned}$$ 改变和式的枚举范围： $$\begin{aligned}B_j&amp;= \sum _{i = j} ^{n - 1} q’ _{n - i - 1} g _{i - j} \\&amp;= \sum _{i = 0} ^{n - j - 1} q’ _{n - j - i - 1} g _i\end{aligned}$$ （如果不明白为什么 $g _{i - j}$ 变为 $g_i$，$q’ _{n - i - 1}$ 却变为 $q’ _{n - j - i - 1}$的话请自己认真好好想一想，两个式子 $i$ 的符号是不一样的） 再令 $t = n - j - 1$，则 $j = n - t - 1$ 并且令 $B’$ 为 $B$ 的反向，即 $B’ _{n - i - 1} = B _i$ 上式可再次变为： $$\begin{aligned}B _j&amp;= \sum _{i = 0} ^{n - j - 1} q’ _{n - j - i - 1} g _i \\B _{n - t - 1}&amp;= \sum _{i = 0} ^t q’ _{t - i} g _i \\B’ _t&amp;= \sum _{i = 0} ^t q’ _{t - i} g _i \\\end{aligned}$$ 可以看到，再次变为多项式卷积形式，求得 $B’$ 后反向即可得到 $B$。 $t$ 跟 $n$ 一样就已经可以求出正确的 $B$ 了，再卷出 $A$ 相减即可。 部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const int maxN = 1e5 + 2;const int maxM = 1 &lt;&lt; 18 | 1;const double pi = acos(-1);int n, lim, log_n;double q[maxN], _q[maxN], g[maxN];int rev[maxM];struct Comp&#123; double real, imag; Comp() &#123; &#125; Comp(double real, double imag) : real(real), imag(imag) &#123; &#125; Comp operator-(const Comp&amp; x) const &#123; return Comp(real - x.real, imag - x.imag); &#125; Comp operator+(const Comp&amp; x) const &#123; return Comp(real + x.real, imag + x.imag); &#125; Comp operator*(const Comp&amp; x) const &#123; return Comp(real * x.real - imag * x.imag, imag * x.real + real * x.imag); &#125; Comp&amp; operator+=(const Comp&amp; x) &#123; *this = *this + x; return *this; &#125; Comp&amp; operator*=(const Comp&amp; x) &#123; *this = *this * x; return *this; &#125;&#125;;inline Comp Omega(int n, int k)&#123; return Comp(cos((k &lt;&lt; 1) * pi / n), sin((k &lt;&lt; 1) * pi / n)); &#125;inline void Init()&#123; for (lim = 1, log_n = 0; lim &lt; (n &lt;&lt; 1); lim &lt;&lt;= 1, ++log_n); for (register int i = 1; i &lt; lim; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (log_n - 1);&#125;inline void DFT(Comp* a, int n, int flag)&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (register int nn = 2, m; nn &lt;= n; nn &lt;&lt;= 1) &#123; m = nn &gt;&gt; 1; for (register Comp* curr = a; curr != a + n; curr += nn) for (register int i = 0; i &lt; m; ++i) &#123; static Comp tmp; tmp = Omega(nn, flag * i) * curr[i + m]; curr[i + m] = curr[i] - tmp, curr[i] += tmp; &#125; &#125;&#125;inline void Mul(double* a, double* b, double* ans)&#123; static Comp _a[maxM], _b[maxM]; for (register int i = 0; i &lt; n; ++i) _a[i] = Comp(a[i], 0), _b[i] = Comp(b[i], 0); for (register int i = n; i &lt; lim; ++i) _a[i] = _b[i] = Comp(0, 0); DFT(_a, lim, 1), DFT(_b, lim, 1); for (register int i = 0; i &lt; lim; ++i) _a[i] *= _b[i]; DFT(_a, lim, -1); for (register int i = 0; i &lt; n; ++i) ans[i] = _a[i].real / lim;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("LGP3338.in", "r", stdin); freopen("LGP3338.out", "w", stdout);#endif scanf("%d", &amp;n); for (register int i = 0; i &lt; n; ++i) &#123; if (i) g[i] = 1.0 / i / i; scanf("%lf", q + i), _q[i] = q[i]; &#125; std::reverse(_q, _q + n), Init(); Mul(q, g, q), Mul(_q, g, _q); for (register int i = 0; i &lt; n; ++i) printf("%lf\n", q[i] - _q[n - i - 1]); return 0;&#125; 有没有觉得代码很好看 【模板】A * B Problem将大整数的每一位视作多项式系数，然后再卷积即可。 代码： 1input(); print(int(input()) * int(input())) 我偏不放 C++ 代码 BZOJ 2194题意Please contact lydsy2012@163.com! 给定一个数 $n$ 以及长度为 $n$ 的序列 $a, b$，要求计算 $$c_k = \sum _{i = k} ^{n - 1} a _i b _{i - k}$$ 数组下标从 0 开始。 $n \le 10^5$，$\forall a _i, b _i \in N$ 且 $\forall a _i, b _i \le 100$。 题解看了上面推的式子，这边看起来就特别裸了… 直接颓柿子了： $$\begin{aligned}c _k&amp;= \sum _{i = k} ^{n - 1} a _i b _{i - k} \\&amp;= \sum _{i = 0} ^{n - k - 1} a _{i + k} b _i \\c’ _{n - k - 1}&amp;= \sum _{i = 0} ^{n - k - 1} a’ _{n - i - k - 1} b _i \\c’ _{t}&amp;= \sum _{i = 0} ^t a’ _{t - i} b _i\end{aligned}$$ 然后就没有然后了。 部分代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const int maxN = 1e5 + 2;const int maxM = 1 &lt;&lt; 18 | 1;const double pi = acos(-1);int n, lim, log_n;int a[maxN], b[maxN], rev[maxM];struct Comp&#123; double real, imag; Comp() &#123; &#125; Comp(double real, double imag) : real(real), imag(imag) &#123; &#125; Comp operator+(const Comp&amp; x) const &#123; return Comp(real + x.real, imag + x.imag); &#125; Comp&amp; operator+=(const Comp&amp; x) &#123; *this = *this + x; return *this; &#125; Comp operator-(const Comp&amp; x) const &#123; return Comp(real - x.real, imag - x.imag); &#125; Comp operator*(const Comp&amp; x) const &#123; return Comp(real * x.real - imag * x.imag, imag * x.real + x.imag * real); &#125; Comp&amp; operator*=(const Comp&amp; x) &#123; *this = *this * x; return *this; &#125;&#125;;inline Comp Omega(int n, int k)&#123; return Comp(cos((k &lt;&lt; 1) * pi / n), sin((k &lt;&lt; 1) * pi / n)); &#125;inline void Init()&#123; for (lim = 1, log_n = 0; lim &lt; (n &lt;&lt; 1); lim &lt;&lt;= 1, ++log_n); for (register int i = 0; i &lt; lim; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (log_n - 1);&#125;inline void DFT(Comp* a, int n, int flag)&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (register int nn = 2, m; nn &lt;= n; nn &lt;&lt;= 1) &#123; m = nn &gt;&gt; 1; for (register Comp* curr = a; curr != a + n; curr += nn) for (register int i = 0; i &lt; m; ++i) &#123; static Comp tmp; tmp = Omega(nn, i * flag) * curr[i + m]; curr[i + m] = curr[i] - tmp, curr[i] += tmp; &#125; &#125;&#125;inline void Mul(int* a, int* b, int* ans)&#123; static Comp _a[maxM], _b[maxM]; for (register int i = 0; i &lt; n; ++i) _a[i] = Comp(a[i], 0), _b[i] = Comp(b[i], 0); for (register int i = n; i &lt; lim; ++i) _a[i] = _b[i] = Comp(0, 0); DFT(_a, lim, 1), DFT(_b, lim, 1); for (register int i = 0; i &lt; lim; ++i) _a[i] *= _b[i]; DFT(_a, lim, -1); for (register int i = 0; i &lt; n; ++i) ans[i] = int(_a[i].real / lim + 0.5);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("BZOJ2194.in", "r", stdin); freopen("BZOJ2194.out", "w", stdout);#endif n = read(); for (register int i = 0; i &lt; n; ++i) a[n - i - 1] = read(), b[i] = read(); Init(); Mul(a, b, a); for (register int i = n - 1; ~i; --i) write(a[i]), putchar('\n'); return 0;&#125; 以后可能还会补充例题的- - Thanks for your consideration!]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[51nod1952]栈]]></title>
    <url>%2Fposts%2F53012%2F</url>
    <content type="text"><![CDATA[前言题面传送门 这里讲的是有别于单调栈和单调队列的做法。 要想看这种做法的，请转至 yongshi的文章 题意要求维护一个异常的栈。 $n$ 次操作，除了正常的栈顶插入删除外，还有一个栈尾插入的操作，每次操作后询问栈内元素最大值。 $n \le 10^7, 0 \le x \le 10^9$（$x$ 表示插入的数）。 时限1.5s，输入由参数产生，输出答案的和对 $10^9 + 7$ 取模的值。 分析显然只能 $\mathcal O(n)$。 考虑没有栈尾插入的时候怎么做。 不需要什么单调栈 + 普通栈，直接用一个栈记录前缀最大值就行了，删除就直接让栈顶指针前移一格。 现在加入了栈尾插入，直接这么搞行不通了。 但即使是这样也不能向单调队列单调栈屈服 正当我冥思苦的时候，旁边的 $\text{zls}$ 突然冒出一句： 另开一个普通栈放栈尾插入的不就行了？每次正常栈pop完了直接暴力把这个新开的栈一个个塞回原栈继续维护前缀最大值就可以了 这么暴力显然过不去啊 然而并不对。其实感性想一想，这样的复杂度貌似是对的… 均摊下来，每个元素最多只会被入新栈一次，入普通栈一次，出栈一次 也就是说，这样子操作的时间复杂度还是 $\mathcal O(n)$ 的 带了个 3 的常数，但实际上比 3 小很多（总共就 $10^7$ 个操作） 具体实现上，新栈因为没有删除操作而只有整体搬空，可以直接用一个全局变量记录新栈的全局最大值； 原栈和原来没有尾部插入一样，不需要记录原数据，直接只记录前缀最大值就可以了。 （不要像我这种 $\text{lese}$ 一样把新栈也搞成前缀最大值…调了半天） 这样子我们就可以以极低的代码，时间，思维复杂度解决这个题目了。 总比想破头去想单调队列 + 单调栈好 代码指针可能不太友好，不过差不多啦- -凑合着看看吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-03-11 12:45 * FileName : 1952.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cassert&gt;#include &lt;algorithm&gt;typedef long long LL;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 1e7 + 2;const int mod = 1e9 + 7;int n, A, B, C, xi, a, aa, b, bb, MOD, ans, max;int stk1[maxN], stk2[maxN], *pos1 = stk1, *pos2 = stk2;inline void Mod(int&amp; x)&#123; x &gt;= mod ? x -= mod : 0; &#125;inline void Getopt()&#123; xi = ((LL)xi * aa + bb) % MOD; if ((pos1 - stk1) + (pos2 - stk2) &lt;= 1) a = 0, b = xi; else &#123; int tmp = xi % (A + B + C); if (tmp &lt; A) a = 0, b = xi; else if (tmp &lt; A + B) a = 1, b = xi; else a = 2; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("1952.in", "r", stdin); freopen("1952.out", "w", stdout);#endif n = read(), A = read(), B = read(), C = read(); xi = read(), aa = read(), bb = read(), MOD = read(); for (register int i = 1; i &lt;= n; ++i) &#123; Getopt(); switch (a) &#123; case 0 : *++pos1 = b; Chkmax(*pos1, *(pos1 - 1)); break; case 1 : Chkmax(max, *++pos2 = b); break; case 2 : if (pos1 == stk1) &#123; max = 0; while (pos2 != stk2) &#123; *++pos1 = *pos2--; Chkmax(*pos1, *(pos1 - 1)); &#125; &#125; --pos1; break; default : assert(false); &#125; Mod(ans += std::max(*pos1, max)); &#125; write(ans); return 0;&#125; $$\huge \text{Thanks for your consideration!}$$]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2Fposts%2F61065%2F</url>
    <content type="text"><![CDATA[在看这篇文章的时候，最好拿出草稿纸在该推的地方动手推一下。 文章里面函数定义域都是 $Z_+$。 前置芝士莫比乌斯反演的大概意义知道 $F$ 与 $f$ 的关系，反推出 $f$ 与 $F$ 的关系。 请注意，这里的 $f$ 和 $F$ 均是函数。 整除分块实际上和莫比乌斯反演关系不大，主要是应用到题目里面经常要用。 一种 $O(\sqrt{n})$ 求得 $$\sum_{i = 1}^{n} \lfloor \frac{n}{i} \rfloor$$ 的方法。 朴素扫描显然是 $O(n)$ 的。但是仔细观察可以发现，答案实际上被分为了几个内部元素相同的块。 例如当 $n = 10$ 时，答案分别为： $$\lfloor \frac{10}{1} \rfloor, \lfloor \frac{10}{2} \rfloor, \cdots,\lfloor \frac{10}{10} \rfloor$$ 即 $$[10], [5], [3], [2, 2], [1, 1, 1, 1, 1]$$ 用 $[\ ]$ 括起来的就是所描述的块。 既然块内元素相同，那么再扫描过去显然是没有必要的；这时，就可以使用一个玄学的公式，得到当前块的区间的右端点： $$\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$$ 证明？不会 写成代码就是： 123456int ans = 0;for (register int l = 1, r; l &lt;= n; l = r + 1)&#123; r = n / (n / l); ans += (r - l + 1) * (n / l);&#125; 复杂度大概是 $O(\sqrt{n})$ 一样不会证 各类定义$d|n$ ：$d$ 整除 $n$，即 $d$ 为 $n$ 的因子 $(a, b)$：$a, b$ 的最大公因数，即 $\text{gcd}(a, b)$ $C^k_n$：组合数，即从 $n$ 个物品中选出 $k$ 个物品的方案数 $[P]$：命题 $P$ 成立，值为 $1$；否则为 $0$ $w(n)$：$n$ 的不同质因子的个数，特别地，$w(1) = 0$ 欧拉函数 $\varphi(n)$：小于等于 $n$ 的正整数中，与 $n$ 互质的数的个数，$\varphi(1) = 1$ 积性函数：当 $\text{gcd}(a,b) = 1$ 时，函数 $f$ 满足 $f(ab) = f(a) \times f(b)$，则称 $f$ 为积性函数。 完全积性函数：去掉 $\text{gcd}(a,b)=1$ 的限制，即对于任意的 $a, b$，函数 $f$ 都有 $f(ab) = f(a) \times f(b)$，则称 $f$ 为完全积性函数。 狄利克雷卷积如开头所说，我们首先需要知道 $F$ 和 $f$ 的关系。 狄利克雷卷积正是数学家发明的用于表达函数间关系的运算。 对于算术函数 $f, g$，定义其狄利克雷卷积为： $$(f \ast g)(n) = \sum_{d | n} f(d)g(\frac n d)$$ 其中的 $\ast$ 即为狄利克雷卷积，你可以将 $(f \ast g)$ 视作一个新函数 $h$，后面的 $(n)$ 是 $h$ 的自变量。 通俗点讲，它就是一种运算符，和 $+, -, \times, \div$ 没有任何区别； 只不过加减乘除对数进行运算，而 $\ast$ 是对函数进行运算。 类似于我们称 $a \times b$ 为“ $a$ 乘 $b$ ”，我一般称 $a \ast b$ 为“ $a$ 卷 $b$ ”。 下面给出一些性质（摘自维基百科）： 交换律：$f \ast g = g \ast f$。 结合律：$f \ast (g \ast h) = (f \ast g) \ast h$ 存在单位函数 $\epsilon(n) = [n = 1]$，使得任意算术函数 $f$ 都满足 $f \ast \epsilon = f$。 若 $f, g$ 为积性函数，那么 $f \ast g$ 也是积性函数。 对于任意算术函数 $f$，若 $f(1) \not= 0$，都有唯一的逆函数 $f^{-1}$，使得 $f^{-1} \ast f = \epsilon$。 1 的证明：显然， $$(f \ast g)(n) = \sum_{d | n} f(d)g(\frac n d) = \sum_{d | n} f(\frac n d) g(d) = (g \ast f)(n)$$ 4 的证明：$(a, b) = 1$ 时， $$\begin{aligned} (f \ast g)(a) \times (f \ast g)(b) &amp;= (\sum_{u|a} f(u)g(\frac{a}{u})) \times (\sum_{v|b} f(v)g(\frac{b}{v})) \\ &amp;= \sum_{u|a} \sum_{v|b} f(u)g(\frac{a}{u})f(v)g(\frac{b}{v} ) \\ &amp;= \sum_{u|a} \sum_{v|b} f(uv)g(\frac{ab}{uv}) \\ &amp;= \sum_{d|ab} f(d)g(\frac{ab}{d}) \\ &amp;= (f \ast g)(ab)\end{aligned}$$ $uv$ 可以变成 $d$，是因为 $(a, b) = 1$。（仔细想想为什么） $\epsilon(n)$ 用人话来讲就是判断一个数是否为 $1$，是函数值就是 $1$，否则就是 $0$。 结合律和 $f \ast \epsilon = f$ 的证明，请手推一下。 逆函数的话暂且不用管，不过你应该也可以想到反演会与逆函数有关了- - 莫比乌斯函数定义： $$\mu(n) = \begin{cases} 1, &amp; n = 1 \\ (-1)^{w(n)}, &amp; n\text{ 的质因子的最大幂次不超过 }1 \\ 0, &amp; \text{其余情况}\end{cases}$$ 易证其为积性函数。 引理： $$\sum_{d|n} \mu(d) = \begin{cases} 1, &amp; n = 1 \\ 0, &amp; n &gt; 1\end{cases}$$ 等号右边其实就是 $\epsilon(n)$。 证明： $n = 1$ 时，显然成立； 否则按照定义，将 $d$ 分解后质因子最大幂次超过 $1$ 的不作考虑（$0$ 对答案显然没有影响）； 那么，剩下的需要考虑的 $d$，就相当于从 $n$ 的各个质因子中取出一部分任意组合。（特别地，将 $d = 1$ 视作取出 $0$ 个质因子） 例如当 $n = 12$ 时，对答案有影响的 $d$，只由 $1$ 和 $2, 3$ 这两个质因子任意组合而成。（此处 $d$ 可等于 $1, 2, 3, 6$，其中 $6 = 2 \times 3$） 从 $w(n)$ 个质因子中取出 $i$ 个，方案数显然是 $C_{w(n)}^i$；对答案的影响，就再乘上 $(-1)^i$ 即可。 于是式子变成了这样： $$\sum_{d|n} \mu(d) = \sum_{i = 0}^{w(n)} C^i_{w(n)} (-1)^i$$ 看起来是不是有点眼熟？回顾一下二项式定理： $$(a + b)^n = \sum_{i = 0}^n C^i_n a^i b^{n - i}$$ 于是将上式乘上 $1^{w(n) - i}$，则可化为： $$\sum_{i = 0}^{w(n)} C^i_{w(n)} (-1)^i 1^{w(n) - i} = (-1 + 1)^{w(n)} = 0$$ 至此得证。 现在有一个问题：这个式子证出来有什么用呢？别急。 这时定义函数 $1(n)$，无论 $n$ 为何值，函数值都为 $1$。 显然，其为完全积性函数，并且对于任意函数 $f$，显然都有以下式子成立： $$(1 \ast f)(n) = \sum_{d|n} f(d)$$ 也就是说： $$\mu \ast 1 = \sum_{d|n} \mu(d) = \epsilon$$ 即 $\mu$ 与 $1$ 互为逆函数。 感性想想都可以知道，与 $1$ 这种函数互逆，一定会有一些特殊的性质，这也就是构造这么一个奇怪函数的理由。 更新：我并不知道莫比乌斯函数和狄利克雷卷积的先后关系，若是 $\text{dalao}$ 知道可以顺便说一下历史- - 然后，这里可以再给出一个神奇的东西： 定义函数 $Id(n) = n$，即函数值等于自变量值，你会发现： $$\varphi \ast 1 = Id \\\mu \ast Id = \varphi$$ 那么接下来，回到正题－－ 莫比乌斯反演直接给出具体内容： 若 $$f(n) = \sum_{d|n} g(d) \tag 1$$ 则 $$ g(n) = \sum_{d|n} \mu(d) f(\frac n d) \tag 2$$ 并且其逆命题也成立。 证明： $(1)$ 式可转化为 $f = 1 \ast g$，$(2)$ 式可转化为 $g = \mu \ast f$。 将 $(1)$ 式两边同卷上 $\mu$： $$f \ast \mu = \mu \ast 1 \ast g$$ 发现 $\mu \ast 1 = \epsilon$，且 $g \ast \epsilon = g$ 则式子变为： $$f \ast \mu = g$$ 至此得证。 证明是不是看起来很简单？毕竟在前面学了一大堆东西，这里再证就显得容易很多了- - 讲完了吗？讲完了。 你肯定还是有点迷糊，那么接下来，我们来看一道例题－－ 例1 $\text{ZAP-Queries}$题目大意$T$ 组询问。 对于给定的正整数 $a, b, x$，求出： $$\sum_{i = 1}^a \sum_{j = 1}^b [(i, j) = x]$$ $1 \le x \le a, b \le 5 \times 10^4$，$T \le 5 \times 10^4$。 分析朴素算法显然 $O(n^2 \text{log} n)$。（这里 $n$ 和 $a, b$ 同阶，且带上了 $\text{gcd}$ 的 $\text{log}$） 怎么把我们所学的莫比乌斯反演的知识应用上去呢？ 观察一下题目所要求的式子，由于 $(i, j) \not = x$ 的情况对答案无影响，不妨将枚举的 $i, j$ 的意义从“具体数字”变为“是 $x$ 的几倍”。 这样就可以保证 $(ix, jx) = x$， 于是式子变为这样： $$\sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} [(i, j) = 1]$$ 这时候，式子中出现了一个有意思的东西：$[(i, j) = 1]$ 这跟单位元 $\epsilon(n) = [n = 1]$ 的样子不是一模一样吗？ 那么开始化式子： $$\begin{aligned} &amp; \sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} [(i, j) = 1] \\ =&amp; \sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} \epsilon((i, j)) \\ =&amp; \sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} \sum_{d|(i, j)} \mu(d)\end{aligned}$$ 由 $d|(i, j)$，可知 $d|i$ 且 $d|j$。那么我们可以考虑更换枚举顺序，同时再次更改 $i, j$ 的意义。 先枚举 $d$，再枚举 $i, j$，此时 $i, j$ 的意义再次变为：“是 $xd$ 的几倍”。 于是式子变成这样： $$\begin{aligned} &amp; \sum_d \mu(d) \sum_{i = 1}^{\lfloor \frac a {xd} \rfloor} \sum_{j = 1}^{\lfloor \frac b {xd} \rfloor} 1 \\ =&amp; \sum_d \mu(d) \lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor\end{aligned}$$ 至此，式子就全部化完了，回答询问时间已经从 $O(n^2 \text{log} n)$ 降为了 $O(n)$。（实际观察式子，$O(n)$ 也只是极端情况，很多时候跑不到） 但是因为有多组询问，我们可以运用上面所讲的整除分块的方法，将处理询问的时间优化到 $O(\sqrt n)$。 具体而言，$\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 这两个式子分别都会有自己的不同的分块。 也就是说，对于当前位置 $l$，$a, b$ 都分别有其对应位置 $r_a = \lfloor \frac a {\lfloor \frac a l \rfloor} \rfloor, r_b = \lfloor \frac b {\lfloor \frac b l \rfloor} \rfloor$ 将 $\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 这两个相乘的式子视作整体，那么只有取 $r_a, r_b$ 中最小的（定义为 $r$），才能保证 $[l, r]$ 中 $\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 全部相等。 既然 $\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 已经全部相等，$\mu(d)$ 用一个简单的前缀和累计一下就可以了。 但是这里再次牵扯出来一个问题：如何快速求出 $\mu$？ 因为 $\mu$ 是积性函数，所以我们稍稍改变一下以前学过的线性筛素数的方法，就可以在线性时间内筛出所有 $\mu(i)$ 的值了。 都学莫比乌斯反演了你不要跟我讲你不会线性筛 （其实有比线性筛更优秀的做法，等我学了再补吧233） 具体而言，若当前数是质数，那么 $\mu$ 值为 $-1$； 设用来筛其他数的当前数为 $i$，遍历到的当前质数为 $p$，那么在 $p$ 小于 $i$ 的最小质因子时， $\mu(pi) = -\mu(i)$。 为什么？仔细想想，在遍历到最小质因子之前，当前数和所遍历到的质数一定互质（显然，要不然就和最小质因子矛盾了） 也就是说，$w(pi) = w(i) + 1$。所以有了上述式子。 如果 $p$ 大于等于 $i$ 最小质因子，就不用筛了（线性筛原理） 实现可以看下代码。 以下是整体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-02-16 10:38 * FileName : else.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;typedef long long LL;typedef unsigned int uint;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 5e4 + 2;int T, a, b, x;LL ans;int mu[maxN], premu[maxN];bool vis[maxN];std::vector&lt;int&gt; prim;inline void Shuffle(int n)&#123; premu[1] = mu[1] = 1; for (register int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) prim.push_back(i), mu[i] = -1; for (register uint j = 0; j &lt; prim.size() and prim[j] * i &lt;= n; ++j) &#123; vis[i * prim[j]] = true; if (i % prim[j]) mu[i * prim[j]] = -mu[i]; else break; &#125; premu[i] = premu[i - 1] + mu[i]; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("else.in", "r", stdin); freopen("else.out", "w", stdout);#endif T = read(), Shuffle(maxN - 2); while (T--) &#123; a = read(), b = read(), x = read(), ans = 0; a /= x, b /= x; for (register int l = 1, r; l &lt;= std::min(a, b); l = r + 1) &#123; r = std::min(a / (a / l), b / (b / l)); ans += (premu[r] - premu[l - 1]) * (LL)(a / l) * (b / l); &#125; write(ans), putchar('\n'); &#125; return 0;&#125; 例2 $\text{YY}$ 的 $\text{GCD}$题目大意$T$ 组数据。 给定 $n, m$，求 $$\sum_{i = 1}^n \sum_{j = 1}^m [(i, j) \in \mathbb P]$$ 其中 $\mathbb P$ 表示质数集合。 $T = 10^4, n, m \le 10^7$。 分析（这里设 $n \le m$） 判其是否为质数可能不太好搞，那我们直接在外面枚举质数就行。 式子变成这样： $$\sum_{p \in \mathbb P} \sum_{i = 1}^n \sum_{j = 1}^m [(i, j) = p]$$ 然后和上一题同理： $$\sum_{p \in \mathbb P} \sum_{d} \mu(d) \lfloor \frac{n}{pd} \rfloor \lfloor \frac{m}{pd} \rfloor$$ 然后就可以愉快地做了 然后 T 飞了。复杂度过高，大概是 $O(T |\mathbb P| \sqrt n)$。 对于这种看似最简化的式子，我们需要一个常用的优化技巧： 令 $x = pd$，则 $d = \frac x p$，式子变为： $$\sum_{p \in \mathbb P} \sum_{d = 1}^{\lfloor \frac n p \rfloor} \mu(\frac x p) \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x} \rfloor$$ 再次改变枚举顺序，把 $x$ 提到前面来： $$\sum_{x = 1}^n \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x} \rfloor \sum_{p \in \mathbb P, p | x} \mu(\frac x p)$$ 可以发现 $$\sum_{p \in \mathbb P, p | x} \mu(\frac x p)$$ 这玩意是可以预处理的，线性筛完枚举质数，算其对其倍数的贡献就行。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-02-16 16:13 * FileName : else.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;bitset&gt;#include &lt;vector&gt;typedef long long LL;typedef unsigned int uint;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 1e7;int T, n, m;LL ans;int mu[maxN + 1], F[maxN + 1];std::bitset&lt;maxN + 1&gt; vis;std::vector&lt;int&gt; prim;inline void Shuffle()&#123; mu[1] = 1, prim.reserve(int(6e5)); for (register int i = 2; i &lt;= maxN; ++i) &#123; if (!vis[i]) prim.push_back(i), mu[i] = -1; for (register uint j = 0; j &lt; prim.size() and i * prim[j] &lt;= maxN; ++j) &#123; vis.set(i * prim[j]); if (i % prim[j]) mu[i * prim[j]] = -mu[i]; else break; &#125; &#125; for (register uint i = 0; i &lt; prim.size(); ++i) for (register int j = 1; prim[i] * j &lt;= maxN; ++j) F[prim[i] * j] += mu[j]; for (register int i = 2; i &lt;= maxN; ++i) F[i] += F[i - 1];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("else.in", "r", stdin); freopen("else.out", "w", stdout);#endif T = read(), Shuffle(); while (T--) &#123; n = read(), m = read(), ans = 0; if (n &gt; m) std::swap(n, m); for (register int l = 1, r; l &lt;= n; l = r + 1) &#123; r = std::min(n / (n / l), m / (m / l)); ans += LL(F[r] - F[l - 1]) * (n / l) * (m / l); &#125; write(ans), putchar('\n'); &#125; return 0;&#125; $\huge \text{To be continued…}$]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板]普通平衡树]]></title>
    <url>%2Fposts%2F28024%2F</url>
    <content type="text"><![CDATA[$\text{Foreword}$To be continued. 本文代码均为指针版. 本文中所说的平衡树指的均是二叉平衡树. 本文中所说的中序遍历指的均是左中右顺序. 题面传送门: Luogu-P3369 前言平衡树板子. 给定 $n$ 次操作, 有且仅有下面6种操作: 插入 $x$. 删除 $x$ (若有多个相同的, 只删除一个). 查询 $x$ 的排名(排名定义: 比当前数小的数的个数+1. 若有多个相同的数, 输出最小的排名). 查询排名为 $x$ 的数. 求 $x$ 的前驱(前驱定义: 大于 $x$ 的最小的数) 求 $x$ 的后继(后继定义: 小于 $x$ 的最大的数) $n \le 10^5,x \in [-10^7,10^7]$. 保证操作合法. 题解平衡树基础之BST(注: 如果你对下文内容看的不是非常明白, 请回来点击这里, 自己操作一番, 可以加深理解) 要学习平衡树, 你首先需要了解二叉查找树(Binary Search Tree, BST). BST定义 树中每个节点都被赋予了一个权值;(这里先假设权值互不相同) 若左子树非空, 则左子树上所有节点的值均小于其根节点的值; 若右子树非空, 则右子树上所有节点的值均大于其根节点的值. 举个例子: 这就是一棵二叉查找树. 看看这张图, 是不是正如我说的一样? 对于66号节点, 左子树中分别为1,19,23,45,54,59, 全部小于66; 右子树中分别为71,77,91, 全部大于66. 对于19号节点, 左子树中分别为1, 全部小于19; 右子树中分别为23,45,54,59, 全部大于19. 现在大致明白了这种神奇的树了吧? 这里给出一个性质: 二叉查找树的中序遍历是一个有序序列. 可以自己动手试一试画一画, 也可以用程序: 12345678910111213141516171819typedef struct Node* ptr; // 将ptr作为Node*这种类型的别称struct Node&#123; int val; ptr left, right; Node(int val) : val(val) // 构造函数, 初始化新节点的左右儿子为空, 值为val &#123; left = right = NULL; &#125;&#125; *root;void Print_Mid(ptr curr_node) // 中序遍历输出&#123; if(!curr_node) // !可用于判断空指针 return; Print_Mid(curr_node-&gt;left); printf("%d\n", curr_node-&gt;val); Print_Mid(curr_node-&gt;right);&#125; 几个基本操作查找特定的值123456789inline ptr Find(int x, ptr curr_node) // 在以curr_node为根的子树中找到值为x的节点&#123; while(curr_node-&gt;val != x) if(x &lt; curr_node-&gt;val) curr_node = curr_node-&gt;left; else curr_node = curr_node-&gt;right; return curr_node;&#125; 利用的还是二叉查找的思想. 查找最值12345678910111213inline ptr Find_Min(ptr curr_node) // 在以curr_node为根的子树中找到最小值&#123; while(curr_node-&gt;left) // 判断左子节点是否存在 curr_node = curr_node-&gt;left; return curr_node;&#125;inline ptr Find_Max(ptr curr_node) // 在以curr_node为根的子树中找到最大值&#123; while(curr_node-&gt;right) curr_node = curr_node-&gt;right; return curr_node;&#125; 同理, 根据二叉查找树的性质可以得出. 插入节点12345678910inline void Insert(int x) // 插入值为x的节点&#123; register ptr curr_node = root; while(curr_node) if(x &lt; curr_node-&gt;val) curr_node = curr_node-&gt;left; else curr_node = curr_node-&gt;right; curr_node = new Node(x);&#125; 同查找节点, 找到适合位置之后新建节点即可. 但是, 上述代码是完全错误的. 如果细心观察会发现: curr_node的改变, 不影响原值. 上述代码所犯错误跟这段代码差不多: 123ptr p = root;p = NULL;// root == NULL? False. p值的修改是不可能影响到root的. 这个例子应该好懂了些吧? 正确代码如下: 123456789101112131415161718192021222324252627282930inline void Insert(int x) // 插入值为x的节点&#123; if(!root) &#123; root = new Node(x); return; &#125; register ptr curr_node = root; while(true) &#123; if(x &lt; curr_node-&gt;val) &#123; if(!curr_node-&gt;left) &#123; curr_node-&gt;left = new Node(x); return; &#125; curr_node = curr_node-&gt;left; &#125; else &#123; if(!curr_node-&gt;right) &#123; curr_node-&gt;right = new Node(x); return; &#125; curr_node = curr_node-&gt;right; &#125; &#125;&#125; 相当于改成这样: 123ptr p = root;p-&gt;left = NULL;// root-&gt;left == NULL? True. 从直接修改当前节点变成了修改当前节点的子节点, 保证了不会出现引用啥啥乱七八糟的问题. 删除节点这里较为复杂. 首先找到该节点, 然后分三种情况讨论 该节点是叶节点. 直接删除. 该节点是链节点(只有一个儿子). 用这个儿子代替它的位置就行. 该节点非叶非链. 这种情况复杂一点, 一般是找到它的后继代替他的位置然后删掉后继. 显然,它的后继一定为链节点或叶节点, 删除后继很好删除. 再用一下上面的图 现在我们要删除19, 只需要找到它的后继23, 将19这个节点的值赋为23后删除23节点即可. (顺便说一句: 有一个23没有变成23是有意义的, 23是特指节点, 23指的是二十三这个数字.) 1234567891011121314151617181920inline void Simple_Delete(ptr&amp; curr_node) // 对应1, 2情况的节点删除&#123; if(curr_node-&gt;left) curr_node = curr_node-&gt;left; else curr_node = curr_node-&gt;right;&#125;inline void Delete(int x) // 删除值为x的节点&#123; ptr curr_node = Find(x, root); if(curr_node-&gt;left and curr_node-&gt;right) &#123; ptr temp = Find_Min(curr_node-&gt;right); curr_node-&gt;val = temp-&gt;val; Simple_Delete(temp); &#125; else Simple_Delete(curr_node);&#125; 然而同样的 代码完全错误- - 请读者自行思考如何写出正确删除操作 一些小提示: Find函数返回值并未引用. 可以像Insert函数的改正一样, 对当前节点的子节点进行操作, 而不是对当前节点操作. 牺牲一小点效率, 写成递归形式.(这样对于参数的引用就非常好处理) 偷个懒, 这个代码就不放了- - 如果实在想不出来, 可以参照下面的Splay中的非递归形式和Treap中的递归形式. 前驱后继定义请参照题面. 要注意的是, 所查询元素可以不是当前树中的元素. 即如果现在树中有1, 22, 333个节点, 我可以查询24的后继(33)和前驱(22). 两个操作差不多, 就只讲后继了. 在find操作里面加点零件就可以了. 定义ret为从根节点走到目前节点为止, 比所查询元素大的最小的元素. 如果当前节点的值大于所查询元素, 更新ret为当前节点的值, 往左子树走; 如果当前节点的值小于所查询元素, 直接往右子树走就行. 原理自己想去 前驱操作把左右和大于小于倒过来就差不多了. 代码: 1234567891011121314151617181920212223242526272829303132333435inline int Pre/*predecessor*/(int val)&#123; register ptr curr = root; register int ret; while(curr) &#123; if(val &gt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; return ret;&#125;inline int Suc/*successor*/(int val)&#123; register ptr curr = root; register _val ret; while(curr) &#123; if(val &lt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[0]; &#125; else curr = curr-&gt;son[1]; &#125; return ret;&#125; 基本操作就讲这么多. 排名相关然而… ??? 题目中的3,4操作呢? 别急. 刚刚讲的是最基础的BST, 真正要支持查询排名节点还需要维护一个东西, 叫size. 这题因为有可重复元素, 还要维护一个东西, 叫cnt. 分别解释一下: size表示以当前节点为根的子树中节点的个数(包含重复元素). cnt表示当前节点有多少个重复元素.(就是val一样, 然后累在一起) 给个定义不够清楚, 还是上刚刚那个图 66的size是10, 19的size是6, 91的size是3, 45的size是4, 77的size是1, 等等. 这图里面元素不重复, 所以cnt没有体现 如果我现在插入19, 它就不会新建节点, 而是使19的cnt++(同时, 19和66的size也会++). 维护了size域之后, 我们就可以着手做3,4操作了 基础思想是分治. 首先可以知道的是, 在一棵子树中, 根节点的排名大小取决于左子树的size. 可以得出, 根节点的权值在这棵子树中的排名是一个闭区间: $[lsize+1,lsize+cnt]$. (为什么说是一个区间, 因为有重复元素. 题目里面明确讲了取最小排名.) (其中 $lsize$ 是左儿子的节点个数, $cnt$ 是当前节点的cnt) 依据这个原理, 分别来做3,4操作: 查询排名第 $k$ 的元素其实排名为 $k$ 就是查找 $k$ 小. 因为BST的中序遍历有序, 所以, 如果将一个BST执行中序遍历, 比当前节点小的数的个数就是左子树的size(这句话需要好好理解一下). 总共三种情况: $lsize &lt; k \le lsize + cnt$ 要查找元素就是当前元素, 直接return即可. $k \le lsize$ 说明要查找的节点在左子树中, 并且在左子树中还是排名第 $k$ (结合我前面说的, 想想为什么). 在左子树继续查找即可. $k&gt;lsize+cnt$ 说明要查找的节点在右子树中, 并且在右子树的排名为 $k-lsize-cnt$ (同样结合我前面那一句话, 想想为什么). 将 $k$ 减去对应值之后再在右子树查找即可. 代码如下: 1234567891011121314151617181920inline int QK/*Query Kth*/(int k)&#123; register ptr curr = root; register int size; while(curr) &#123; size = Size(curr-&gt;son[0]); if(k &gt; size and k &lt;= size + curr-&gt;cnt) return curr-&gt;val; if(k &lt;= size) curr = curr-&gt;son[0]; else &#123; k -= size + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; &#125; assert(false); // 正常的话会在while循环里面就return掉了, 如果执行到这里说明程序挂了, 这个指令会自动RE&#125; 查询元素排名(本题中保证所查询的元素现在一定存在). 这和上述查找 $k$ 小的操作非常类似, 可以近似认为是互逆运算(其实它更好理解一些). 过程和find差不多, 但是需要额外定义一个k, 表示从根节点遍历到目前为止, 比所查询元素大的元素个数(初始化为0). 在find的过程中, 如果你需要往左走, 对于k值是无影响的; 而如果要往右走, 则k需要加上左子树的size和当前节点的cnt. 结合代码理解一下(最后k还加上一个值, 是因为比查找到的节点小的数也包括了其左子树的size, 而在循环中是没有加上的): 123456789101112131415161718inline int QR/*Query Rank*/(int val)&#123; register ptr curr = root; register int k = 0; while(curr-&gt;val != val) &#123; if(curr-&gt;val &lt; val) &#123; k += Size(curr-&gt;son[0]) + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; k += Size(curr-&gt;son[0]) + 1; return k;&#125; 平衡树引入经过刚刚的一通乱讲说明, 这道题已经可以做了, 但时间复杂度还无法保证. 非常显然,BST各个操作的时间复杂度均为 $O(h)$. 其中 $h​$ 为二叉搜索树的高度. 然而BST极其可能会退化成一条链, 或者说树深度过深, 导致 $h$ 趋近于 $n$, 显然每个操作 $O(n)$ 的复杂度是我们无法接受的. 这个时候, 就需要我们的平衡树来救场了. 其实平衡树的本质就是BST加上调整. 调整一般有几种(OI用): 旋转, 重构, 分裂合并. 典型的代表就是 Splay, 替罪羊树, fhq Treap. SplaySplay是平衡树的一种. 由Tarjan和Daniel Sleator开发.(感觉信息这方面哪里都能看见Tarjan…) 它的核心操作只有一个:Splay(顾名思义, 伸展操作). 节点定义Splay本质而言还是一棵树, 我们要先确定其节点要存放什么东西. 相对BST的节点要存的东西其实也没多多少, 只是多了一个父指针指向父亲而已. (其实也有递归实现的无父指针版, 如果想学可以参考这里) 先留个坑- -放个代码在这里2333 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2018-12-11 19:26 * FileName : new.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cassert&gt;class Istream&#123; char *ipos;public : Istream() &#123;#ifndef ONLINE_JUDGE freopen("new.in", "r", stdin); freopen("new.out", "w", stdout);#endif ipos = (char*)mmap(NULL, lseek(0, 0, SEEK_END), PROT_READ, MAP_PRIVATE, 0, 0); &#125; Istream&amp; operator&gt;&gt;(int&amp; n) &#123; register bool flag = false; n = 0; while(!isdigit(*ipos)) &#123; if(*ipos == '-') flag = true; ++ipos; &#125; while(n = (n &lt;&lt; 3) + (n &lt;&lt; 1) + (*ipos++ &amp; 15), isdigit(*ipos)); if(flag) n = -n; return *this; &#125;&#125; in;char _obuf[1 &lt;&lt; 20], _stk[20];class Ostream&#123; char *opos, *oend, *stkpos;public : Ostream() &#123; oend = (opos = _obuf) + (1 &lt;&lt; 20) - 1; stkpos = _stk; &#125; ~Ostream() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; void Putchar(char ch) &#123; *opos = ch; if(opos == oend) &#123; fwrite(_obuf, 1, 1 &lt;&lt; 20, stdout); opos = _obuf; &#125; ++opos; &#125; Ostream&amp; operator&lt;&lt;(int n) &#123; if(n &lt; 0) &#123; Putchar('-'); n = -n; &#125; do &#123; *++stkpos = n % 10 ^ 48; n /= 10; &#125; while(n); while(stkpos != _stk) Putchar(*stkpos--); return *this; &#125; Ostream&amp; operator&lt;&lt;(char c) &#123; Putchar(c); return *this; &#125;&#125; out;template&lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;template&lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template&lt;typename _val&gt;struct Splay_Node&#123; typedef Splay_Node &lt;_val&gt;* ptr; ptr son[2], fa; _val val; int size, cnt; Splay_Node(const _val&amp; val, ptr fa) : val(val), fa(fa) &#123; size = cnt = 1; son[0] = son[1] = NULL; &#125;&#125;;template&lt;typename _val&gt;class Splay_Tree&#123; typedef Splay_Node &lt;_val&gt;* ptr; ptr root; public : Splay_Tree() &#123; root = NULL; &#125; int Ident/*Identify*/(ptr x) &#123; return x-&gt;fa == NULL ? 0 : x-&gt;fa-&gt;son[1] == x; &#125; int Size(ptr x) &#123; return x == NULL ? 0 : x-&gt;size; &#125; void Update(ptr x) &#123; x-&gt;size = Size(x-&gt;son[0]) + Size(x-&gt;son[1]) + x-&gt;cnt; &#125; void Link(ptr fa, ptr son, int dir/*direction*/) &#123; if(!fa) root = son; else fa-&gt;son[dir] = son; if(son) son-&gt;fa = fa; &#125; void Rotate(ptr x) &#123; register ptr fa = x-&gt;fa; register int dir = Ident(x); Link(fa-&gt;fa, x, Ident(fa)); Link(fa, x-&gt;son[dir ^ 1], dir); Link(x, fa, dir ^ 1); Update(fa); &#125; void Splay(ptr x, ptr goal) &#123; register ptr fa; while(x-&gt;fa != goal) &#123; fa = x-&gt;fa; if(fa-&gt;fa == goal) &#123; Rotate(x); break; &#125; if(Ident(fa) ^ Ident(x)) Rotate(x); else Rotate(fa); Rotate(x); &#125; Update(x); &#125; void Insert(const _val&amp; val) &#123; if(!root) &#123; root = new Splay_Node&lt;_val&gt;(val, NULL); return; &#125; register ptr curr = root; register int dir = val &gt; curr-&gt;val; while(true) &#123; ++curr-&gt;size; if(curr-&gt;val == val) &#123; ++curr-&gt;cnt; return; &#125; dir = val &gt; curr-&gt;val; if(curr-&gt;son[dir]) curr = curr-&gt;son[dir]; else &#123; curr-&gt;son[dir] = new Splay_Node&lt;_val&gt;(val, curr); Splay(curr-&gt;son[dir], NULL); return; &#125; &#125; &#125; void Delete(const _val&amp; val) &#123; register ptr curr/*current*/ = root, pre/*predecessor*/; while(curr-&gt;val != val) curr = curr-&gt;son[val &gt; curr-&gt;val]; Splay(curr, NULL); if(curr-&gt;cnt &gt; 1) &#123; --curr-&gt;cnt, --curr-&gt;size; return; &#125; pre = curr-&gt;son[0]; if(pre) &#123; while(pre-&gt;son[1]) pre = pre-&gt;son[1]; Splay(pre, curr); root = pre; root-&gt;fa = NULL, root-&gt;son[1] = curr-&gt;son[1]; if(root-&gt;son[1]) &#123; root-&gt;son[1]-&gt;fa = root; root-&gt;size += root-&gt;son[1]-&gt;size; &#125; &#125; else &#123; root = curr-&gt;son[1]; if(root) root-&gt;fa = NULL; &#125; delete curr; &#125; int QR/*Query Rank*/(const _val&amp; val) &#123; register ptr curr = root; register int k = 0; while(curr-&gt;val != val) &#123; if(curr-&gt;val &lt; val) &#123; k += Size(curr-&gt;son[0]) + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; k += Size(curr-&gt;son[0]) + 1; Splay(curr, NULL); return k; &#125; _val QK/*Query Kth*/(int k) &#123; register ptr curr = root; register int size; while(curr) &#123; size = Size(curr-&gt;son[0]); if(k &gt; size and k &lt;= size + curr-&gt;cnt) return curr-&gt;val; if(k &lt;= size) curr = curr-&gt;son[0]; else &#123; k -= size + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; &#125; assert(false); &#125; _val Pre(const _val&amp; val) &#123; register ptr curr = root; register _val ret; while(curr) &#123; if(val &gt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; return ret; &#125; _val Suc/*successor*/(const _val&amp; val) &#123; register ptr curr = root; register _val ret; while(curr) &#123; if(val &lt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[0]; &#125; else curr = curr-&gt;son[1]; &#125; return ret; &#125;&#125;;int main()&#123; register int n, opt, x; Splay_Tree&lt;int&gt; wib; in &gt;&gt; n; while(n--) &#123; in &gt;&gt; opt &gt;&gt; x; switch(opt) &#123; case 1 : wib.Insert(x); break; case 2 : wib.Delete(x); break; case 3 : out &lt;&lt; wib.QR(x) &lt;&lt; '\n'; break; case 4 : out &lt;&lt; wib.QK(x) &lt;&lt; '\n'; break; case 5 : out &lt;&lt; wib.Pre(x) &lt;&lt; '\n'; break; case 6 : out &lt;&lt; wib.Suc(x) &lt;&lt; '\n'; break; &#125; &#125;&#125; TreapTreap是一种相对较为随机的平衡树. 具体来说, 就是对每个节点赋一个优先级. 保证不破坏其二叉查找树的本质的同时, 使节点按所赋的优先级排为堆序. 继续留坑(代码比较丑, 到时候重写一下再放上来)]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2007]报表统计]]></title>
    <url>%2Fposts%2F13447%2F</url>
    <content type="text"><![CDATA[前言题面传送门: Luogu-P1110. 本文中使用的是set &amp;&amp; multiset, 并非平衡树. 洛咕题解第一篇和我的思路撞到一起了. 但好歹是我自己想出来的比较玄学的做法 写写题解记录记录2333 题目描述给你一个长度为 $n$ 的非负整数序列. 总共有以下三种操作: INSERT i k: 在原数列的第 $i$ 个元素后添加一个新元素 $k$. MIN_GAP: 查询相邻两元素之间差值(绝对值)的最小值. MIN_SORT_GAP: 查询所有元素中数值大小最接近的两个元素的差值(绝对值). 共 $m$ 次操作, $n,m \le 5 \times 10^5$. 题目分析初步思路首先要注意到 INSERT 操作是在原数列的元素后插入. 举个例子: 原数列为: $\lbrace 5,3,1 \rbrace$ 现在 INSERT 2 9 对应结果: $\lbrace 5,3,9,1 \rbrace$ 再 INSERT 2 4 对应结果: $\lbrace 5,3,9,4,1 \rbrace$ 相当于原数列的每个数挂了条链表. 3 操作倒是很好搞, 跟这道题差不多, 搞一个 std::set, 每次插入数的时候用其与前驱和后继的差值更新答案即可. 重点在 1,2 操作. 暴力优先考虑暴力一点的做法: 设原数列每个元素为 $a _{1 \dots n}$. 先把所有的相邻两数差的绝对值 丢到 std::multiset 里面，也就是插入 $|a_i-a_{i+1}|$。 INSERT 操作的时候, 对于给出的 $i$, 删掉原本的差，加入新的由它贡献出来的差，也就是删除 $|lsta_i-a_{i+1}|$，加入 $|k-lsta_i|,|k-a_{i+1}|$ (其中 $lsta_i$ 表示 $a_i$ 所挂的链的最后一个数) 每次查询输出 *std::multiset.begin(). 在这个思想的基础上, 原本麻烦的 INSERT 操作也免了 因为在 $a_i$ 挂上的一条链中, 我们只需要用到 $lsta_i$ 直接用另一个数组维护一下就可以了. 复杂度这是不是太暴力了? 其实仔细回忆下上面的过程，貌似复杂度就只有 multiset 带来的 $\log$… 总时间复杂度 $\cal O(m \log n)$。 实现细节 注意set的边界问题. 实在不想处理可以一开始就插入INF &amp;&amp; -INF. 注意维护 $lsta_i$ 的数组的初值赋为 $a_i$. 当 $i=n$, $a_{i+1}$ 是不存在的. (可能只有我一个人犯的错误) 用fread用惯之后在这个题写了个字符串读入, 然后写挂了, 交上去全TLE… 搞得我怀疑了半天人生 最后只好用getchar读优 然而不开O2最后一个点好像死活过不去… 可能我的常数不够优秀吧 若使用 multiset.erase(val), 则 multiset 会删除键值等于 val 的所有元素。所以需要 multiset.erase(multiset.find(val)) 来删除单个的迭代器。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2018-11-26 19:10 * FileName : wib.cpp * Website : endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;set&gt;template&lt;typename _Tp&gt;inline bool chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? (x = y, true) : false; &#125;template&lt;typename _Tp&gt;inline _Tp abs(const _Tp&amp; x)&#123; return x &lt; 0 ? -x : x; &#125;const int maxN = 5e5 + 2;const int INF = 0x7FFFFFFF;int n, m, sort_ans = INF, ans = INF, temp, last;int a[2][maxN];std::set&lt;int&gt; SET1;std::multiset&lt;int&gt; SET2;std::set&lt;int&gt;::iterator it;char opt[15];inline void Check(int val)&#123; if(!SET1.empty()) &#123; it = SET1.lower_bound(val); if(it != SET1.end()) &#123; chkmin(sort_ans, *it - val); if(it != SET1.begin()) chkmin(sort_ans, val - *--it); &#125; else chkmin(sort_ans, val - *--it); &#125; SET1.insert(val);&#125;inline void Insert(int pos, int val)&#123; SET2.insert(abs(val - a[1][pos])); if(pos != n) &#123; SET2.insert(abs(val - a[0][pos + 1])); SET2.erase(SET2.find(abs(a[1][pos] - a[0][pos + 1]))); &#125; a[1][pos] = val;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(register int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;temp); Check(temp); if(i != 1) SET2.insert(abs(temp - last)); a[0][i] = a[1][i] = last = temp; &#125; while(m--) &#123; scanf("%s", opt); switch(opt[4]) &#123; case 'R' : scanf("%d%d", &amp;temp, &amp;last); Insert(temp, last); Check(last); break; case 'S' : printf("%d\n", sort_ans); break; case 'G' : printf("%d\n", *SET2.begin()); break; &#125; &#125; return 0;&#125; Thanks for your consideration!]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2Fposts%2F53593%2F</url>
    <content type="text"><![CDATA[转眼间, 人生第一次NOIP就结束了. 成绩并不让人满意, 但是为了记录下自己的OI历程以及警醒以后的自己, 遂写下此文, 期望能够有所感悟和改进. Day -31初赛考完了之后过了两周, 信息组正式宣布停课. 早就迫不及待了. 因此也逃过了期中考试 每天上午考试, 下午讲题, 晚上改题+自练, 循环往复, 周而复始. 但是我们考的比赛是NOI Professional… 完全超过了提高组的考点了好吗 就这样, 习惯于被高二和本届dalao暴踩, NOIP也越来越近… Day 0上午搞了个联赛总动员, 大致意思就是鼓励大家调整心态 然后这一下午和晚上都放了假. 晚上就跑去看了一下毒液.(事实证明考前跑去看电影好像对心态平复不利…) 11:00躺到床上, 一直心绪不宁, 到12:30才勉强睡着… 毕竟是第一次考联赛, 况且考不好就会变成最后一次emm 还是挺紧张的 Day 16:20爬起来, 去食堂匆匆吃了个早饭, 7:10左右车子就出发了. 到地方的时候才7:40左右, 考场还得等半个小时才开, 百无聊赖的站了半个小时. 看到4个国集dalao在旁边说话, 被他们的气场震得瑟瑟发抖 8:10放进考场, 调了会vimrc之后就发密码了. (当时根本不知道飞雪连天是什么意思…) 首先看了一下T1, $O(nlogn)$ 线段树解法??? 大致看一下没什么特别好的思路, 把T2和T3都看了一遍 大凯的疑惑??? 二分答案+树形DP??? 除了T3部分分之外感觉都十分不可做, 又滚回来肝T1 想了半个小时没个结果, 只想出个70分的暴力…打完就走了 又去肝T2, 因心态已经有点爆炸(T1都打不全, T2T3没一点思路), 心里特别乱, 连大样例都没有手推, 凭空往数论方面想了好久…自然是什么都打不出来(当时我还认为T2是个省选/NOI-) 到放弃T2再看T3, 心态已经完全炸了. 思路杂乱自然什么都做不了, 又想着想正解又想着部分分怎么拿, 于是T3正解也没想出来, $a_i=1$ 的部分分也没有拿, 匆匆拿了个40就走了. 滚回去看T2, 这时候已经10:20了… 当时是有点绝望了 看了一眼T2的大样例, 我突然有个大胆的猜想: b绝对是a的子集? 又想了五分钟, 想到了筛法 手推了三组样例, 发现是对的时候, 心态有所恢复- - 打了个复杂度极高的筛法, 一发过了大样例. 于是期望得分+=80. 这时候11:00了都… 然后在T1和T3之间一直徘徊…两题都没思路 后来就调自己T3的部分分, 确保有40之后就放弃了. 于是D1期望得分70+80+40=190. 当时因为在绝境中打出了T2的80分, 所以出考场的时候心态还算平静 出去一交流: 我: 你们今天打的怎么样? zqr: T1 100, T2 80, T3 40, 大概220吧. 我: WA TQL! T1你怎么打出来的? zqr: 套个线段树乱搞, 过了 $10^5$ 的大样例233 wzr: 啊? T1不是2013的原题吗? 在洛咕上好像是普及-吧 还有T3不是能骗55分吗? $a_i=1$ 挺好写的啊 我&amp;zqr:……. 于是乎 心态再次爆炸 下午回去自测, 洛咕数据比较水, T1有80, T2直接满了(后来洛谷加了个最毒瘤的重测卡成了95), T3如预期拿到了40 还好没有挂分, 只能祝自己Day2 rp++了… 和我爸出去吃了个饭, 随便晃晃, 回机房的时候都20:30了 我们机房(都是新学4个月的人)有个AK的神仙 orz 没再复习了 注重于调整心态(实际上没什么用) 晚上依然睡不着觉 0:00勉强睡着 Day 2和昨天上午一样, 准时出发, 7:45到了. 又等了好久才放进考场. 进去重配了vimrc, 然后 笑书神侠?? 啥玩意?? 并不理解其中意义, 抓紧时间看题面 果然如他们所言, D2难度上了个档次T1看完题面, ??? 这是能做的??? 看到 $m=n-1\ or\ m=n$ 才放心- - 在看一眼T2 题意都看的不是很明白…果断放弃 T3 特别迷… 又是个树形DP吗… 哪有DP这样子带修改的… (出考场才反应出来是动态DP) 这怕是我们考的NOI Professional的难度 转回T1, 10min打完了60, 心态良好 然后开始搞基环树的40分 这中间折腾了一个小时, 想出一个时间复杂度非常优秀的做法 $O(nlogn)$ 后来我的分数告诉我 我看错题意了 我没怎么深刻理解题意 直接当做一条边可以走两次 实际上有个非常重要的东西 …, 走向一个没有去过的城市, … 当时打上去调了半小时过了大样例, 试了组极限数据保证不TLE之后就欢天喜地的扔掉了T1 继续看T2 觉得十分不可做 部分分都没看就看T3去了 然后依然没有任何头绪… 做过原题都想不起来… 浪费一个小时毫无建树… 心态爆炸.jpg 之后连 $O(n!)$ 的暴力 $20pts$ 都不想打了 直接扔掉了这道题 11:20左右才又开始看T2… 看到 $n \le 2$ 的部分分的时候已经11:40了 只把 $n,m \le 3$ 的数据打了(实际上只打了一部分 $n=2,m=3\ or\ n=3,m=2$ 这部分没时间推了…) 出考场的时候心态已经完全崩了 预计得分100+15+0=115 因为我没有在T2上花什么时间 想不出来很正常 所以我最怕出考场的时候出现这种对话: 我: 打的怎么样? zqr: 60+100+44=204吧 当时脑子里觉得可能会出现这种情况 心态已经完全爆炸了 交流了下发现没有… T2都不会写 暂且松了口气 回去自测才发现T1挂了…挂掉30 T2 15分, T3 0分 预估的最低得分是70+80+40+72+10+0=272 完全绝望 大致和同学聊了一会 我已经快垫底了 GC神仙400+了已经…同是新人为什么我这么菜呢… 事已至此, 再怎么做都无法挽回了 于是晚上思考人生+平复心态 改题都不怎么想改… dalao聊成绩的时候被各种暴踩 就当给自己锻炼心态了- - 以前打了那么久的LOL练的心态可不是白练的 只能祈求NOIP的数据水一点了 Day 4上午上文化, 中午依然来机房过快乐日子 这才听到他们说我们本校的毒瘤数据出了 每个人测了一遍 GC神仙430 orz 大着胆子看了一眼自己的成绩 90+100+55+84+15+0=344 ??????????????????????????????????????????????????????????????????? 这真的是毒瘤数据???? 但别人好像分数都挺正常的…唯独我的拉上去了70分 虽然知道344是不可能的, 但是好歹还是让我心态略微平复了一点 笑容渐渐恢复 Day 6学军的数据来了. 果然很毒瘤, 我一落千丈: 70+80+40+68+15+0=273 跟最低预估分差不多了. 不过还好吧, 毕竟现在我的分数范围变成了273-344了- - 希望NOIP给个救命分吧2333 中午顺便改了改简单的题 D1T1T2, D2T1都改了 Day 10听说今天早上成绩会出. 10:00大课间匆匆跑过来 成绩单未上传, 请稍后查看! 还是等明天吧… Day 11早上7:00, 我爸就打电话过来说出了. 我发了账号密码过去叫他帮我查. 7:30左右他回了电话过来 当时我还在食堂为作业写不完发愁 319. NOIP还是挺给面子的. 后来查到如文章开头所示的各题得分, 让我惊讶的一点是D1T2NOIP的数据20分都放过去了, 挺良心的- - 还有D2T1错解得了个84, 正常得分应该是72的233 尾声仔细想想, 还是自己基础不够扎实, 也有一些心态上的问题, 导致了联赛考的如此之差. 就比如D1T2, 要不是lzhdalao说”这题比砝码称重不知道简单到哪里去了”, 我都根本想不起来我做过砝码称重这道题. 要是当时能想起来, D1T2应该是可以10min切掉的. T1就不说了… 自己过分自大看不起普及-, 但就是这题我想不出来. (数据范围放了 $O(n\text{log}n)$ 过去, 但我也没打) T3的话, 如果能在1h内搞完T1和T2, 用两个半小时我应该还是能想出来的 D2的话 T1错在没认真读题 (小插曲: 当时我改题的时候下了一波洛咕的数据, 看完输入输出后还以为洛咕数据是错的- -打算投诉的时候csydalao闻讯赶来, 嘲讽了我一波, 我那时候才知道理解错了) T2的话就随缘了… $n \le 2$ 时间给多应该可以推出来 T3就不说了 那44分的教训可以让我铭记一生 恬不知耻的算了一下最高得分: 100+100+55+100+65+44=464, 这也就是现阶段的我状态最好最好最好下能拿到的分数了(然而 $tan\ \frac{k\pi}{2},k \in Z$) 强行苟在组里没有退役, 这次的教训已经够惨重了, 加油吧. 也有一些朋友退役了… 衷心的祝愿文化课快乐. Update in 12.4HN的分数线是305. 虽然我知道今年分数线放了很多水, 省一并不值钱, 但是听到消息的时候还是很高兴的. 为csy的302默哀… 接下来的一年, 尽管莽吧 Thanks for your reading.]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2Fposts%2F22462%2F</url>
    <content type="text"><![CDATA[$\text{Welcome to my blog!}$折腾了好久 终于搭好了2333 用于记录自己的各类经历- - 1234#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl; &#125;]]></content>
      <categories>
        <category>感想</category>
      </categories>
  </entry>
</search>
