<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94.html</url>
    <content type="text"><![CDATA[在看这篇文章的时候，最好拿出草稿纸在该推的地方动手推一下。 文章里面函数定义域都是 $Z_+$。 前置芝士莫比乌斯反演的大概意义知道 $F$ 与 $f$ 的关系，反推出 $f$ 与 $F$ 的关系。 请注意，这里的 $f$ 和 $F$ 均是函数。 整除分块实际上和莫比乌斯反演关系不大，主要是应用到题目里面经常要用。 一种 $O(\sqrt{n})$ 求得 $$\sum_{i = 1}^{n} \lfloor \frac{n}{i} \rfloor$$ 的方法。 朴素扫描显然是 $O(n)$ 的。但是仔细观察可以发现，答案实际上被分为了几个内部元素相同的块。 例如当 $n = 10$ 时，答案分别为： $$\lfloor \frac{10}{1} \rfloor, \lfloor \frac{10}{2} \rfloor, \cdots,\lfloor \frac{10}{10} \rfloor$$ 即 $$[10], [5], [3], [2, 2], [1, 1, 1, 1, 1]$$ 用 $[\ ]$ 括起来的就是所描述的块。 既然块内元素相同，那么再扫描过去显然是没有必要的；这时，就可以使用一个玄学的公式，得到当前块的区间的右端点： $$\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$$ 证明？不会 写成代码就是： 123456int ans = 0;for (register int l = 1, r; l &lt;= n; l = r + 1)&#123; r = n / (n / l); ans += (r - l + 1) * (n / l);&#125; 复杂度大概是 $O(\sqrt{n})$ 一样不会证 各类定义$d|n$ ：$d$ 整除 $n$，即 $d$ 为 $n$ 的因子 $(a, b)$：$a, b$ 的最大公因数，即 $\text{gcd}(a, b)$ $C^k_n$：组合数，即从 $n$ 个物品中选出 $k$ 个物品的方案数 $[P]$：命题 $P$ 成立，值为 $1$；否则为 $0$ $w(n)$：$n$ 的不同质因子的个数，特别地，$w(1) = 0$ 欧拉函数 $\varphi(n)$：小于等于 $n$ 的正整数中，与 $n$ 互质的数的个数，$\varphi(1) = 1$ 积性函数：当 $\text{gcd}(a,b) = 1$ 时，函数 $f$ 满足 $f(ab) = f(a) \times f(b)$，则称 $f$ 为积性函数。 完全积性函数：去掉 $\text{gcd}(a,b)=1$ 的限制，即对于任意的 $a, b$，函数 $f$ 都有 $f(ab) = f(a) \times f(b)$，则称 $f$ 为完全积性函数。 狄利克雷卷积如开头所说，我们首先需要知道 $F$ 和 $f$ 的关系。 狄利克雷卷积正是数学家发明的用于表达函数间关系的运算。 对于算术函数 $f, g$，定义其狄利克雷卷积为： $$(f \ast g)(n) = \sum_{d | n} f(d)g(\frac n d)$$ 其中的 $\ast$ 即为狄利克雷卷积，你可以将 $(f \ast g)$ 视作一个新函数 $h$，后面的 $(n)$ 是 $h$ 的自变量。 通俗点讲，它就是一种运算符，和 $+, -, \times, \div$ 没有任何区别； 只不过加减乘除对数进行运算，而 $\ast$ 是对函数进行运算。 类似于我们称 $a \times b$ 为“ $a$ 乘 $b$ ”，我一般称 $a \ast b$ 为“ $a$ 卷 $b$ ”。 下面给出一些性质（摘自维基百科）： 交换律：$f \ast g = g \ast f$。 结合律：$f \ast (g \ast h) = (f \ast g) \ast h$ 存在单位函数 $\epsilon(n) = [n = 1]$，使得任意算术函数 $f$ 都满足 $f \ast \epsilon = f$。 若 $f, g$ 为积性函数，那么 $f \ast g$ 也是积性函数。 对于任意算术函数 $f$，若 $f(1) \not= 0$，都有唯一的逆函数 $f^{-1}$，使得 $f^{-1} \ast f = \epsilon$。 1 的证明：显然， $$(f \ast g)(n) = \sum_{d | n} f(d)g(\frac n d) = \sum_{d | n} f(\frac n d) g(d) = (g \ast f)(n)$$ 4 的证明：$(a, b) = 1$ 时， $$\begin{aligned} (f \ast g)(a) \times (f \ast g)(b) &amp;= (\sum_{u|a} f(u)g(\frac{a}{u})) \times (\sum_{v|b} f(v)g(\frac{b}{v})) \\ &amp;= \sum_{u|a} \sum_{v|b} f(u)g(\frac{a}{u})f(v)g(\frac{b}{v} ) \\ &amp;= \sum_{u|a} \sum_{v|b} f(uv)g(\frac{ab}{uv}) \\ &amp;= \sum_{d|ab} f(d)g(\frac{ab}{d}) \\ &amp;= (f \ast g)(ab)\end{aligned}$$ $uv$ 可以变成 $d$，是因为 $(a, b) = 1$。（仔细想想为什么） $\epsilon(n)$ 用人话来讲就是判断一个数是否为 $1$，是函数值就是 $1$，否则就是 $0$。 结合律和 $f \ast \epsilon = f$ 的证明，请手推一下。 逆函数的话暂且不用管，不过你应该也可以想到反演会与逆函数有关了- - 莫比乌斯函数定义： $$\mu(n) = \begin{cases} 1, &amp; n = 1 \\ (-1)^{w(n)}, &amp; n\text{ 的质因子的最大幂次不超过 }1 \\ 0, &amp; \text{其余情况}\end{cases}$$ 易证其为积性函数。 引理： $$\sum_{d|n} \mu(d) = \begin{cases} 1, &amp; n = 1 \\ 0, &amp; n &gt; 1\end{cases}$$ 等号右边其实就是 $\epsilon(d)$。 证明： $n = 1$ 时，显然成立； 否则按照定义，将 $d$ 分解后质因子最大幂次超过 $1$ 的不作考虑（$0$ 对答案显然没有影响）； 那么，剩下的需要考虑的 $d$，就相当于从 $n$ 的各个质因子中取出一部分任意组合。（特别地，将 $d = 1$ 视作取出 $0$ 个质因子） 例如当 $n = 12$ 时，对答案有影响的 $d$，只由 $1$ 和 $2, 3$ 这两个质因子任意组合而成。（此处 $d$ 可等于 $1, 2, 3, 6$，其中 $6 = 2 \times 3$） 从 $w(n)$ 个质因子中取出 $i$ 个，方案数显然是 $C_{w(n)}^i$；对答案的影响，就再乘上 $(-1)^i$ 即可。 于是式子变成了这样： $$\sum_{d|n} \mu(d) = \sum_{i = 0}^{w(n)} C^i_{w(n)} (-1)^i$$ 看起来是不是有点眼熟？回顾一下二项式定理： $$(a + b)^n = \sum_{i = 0}^n C^i_n a^i b^{n - i}$$ 于是将上式乘上 $1^{w(n) - i}$，则可化为： $$\sum_{i = 0}^{w(n)} C^i_{w(n)} (-1)^i 1^{w(n) - i} = (-1 + 1)^{w(n)} = 0$$ 至此得证。 现在有一个问题：这个式子证出来有什么用呢？别急。 这时定义函数 $1(n)$，无论 $n$ 为何值，函数值都为 $1$。 显然，其为完全积性函数，并且对于任意函数 $f$，显然都有以下式子成立： $$(1 \ast f)(n) = \sum_{d|n} f(d)$$ 也就是说： $$\mu \ast 1 = \sum_{d|n} \mu(d) = \epsilon$$ 即 $\mu$ 与 $1$ 互为逆函数。 感性想想都可以知道，与 $1$ 这种函数互逆，一定会有一些特殊的性质，这也就是构造这么一个奇怪函数的理由。 更新：我并不知道莫比乌斯函数和狄利克雷卷积的先后关系，若是 $\text{dalao}$ 知道可以顺便说一下历史- - 然后，这里可以再给出一个神奇的东西： 定义函数 $Id(n) = n$，即函数值等于自变量值，你会发现： $$\varphi \ast 1 = Id \\\mu \ast Id = \varphi$$ 那么接下来，回到正题－－ 莫比乌斯反演直接给出具体内容： 若 $$f(n) = \sum_{d|n} g(d) \tag 1$$ 则 $$ g(n) = \sum_{d|n} \mu(d) f(\frac n d) \tag 2$$ 并且其逆命题也成立。 证明： $(1)$ 式可转化为 $f = 1 \ast g$，$(2)$ 式可转化为 $g = \mu \ast f$。 将 $(1)$ 式两边同卷上 $\mu$： $$f \ast \mu = \mu \ast 1 \ast g$$ 发现 $\mu \ast 1 = \epsilon$，且 $g \ast \epsilon = g$ 则式子变为： $$f \ast \mu = g$$ 至此得证。 证明是不是看起来很简单？毕竟在前面学了一大堆东西，这里再证就显得容易很多了- - 讲完了吗？讲完了。 你肯定还是有点迷糊，那么接下来，我们来看一道例题－－ 例1 $\text{ZAP-Queries}$题目大意$T$ 组询问。 对于给定的正整数 $a, b, x$，求出： $$\sum_{i = 1}^a \sum_{j = 1}^b [(i, j) = x]$$ $1 \le x \le a, b \le 5 \times 10^4$，$T \le 5 \times 10^4$。 分析朴素算法显然 $O(n^2 \text{log} n)$。（这里 $n$ 和 $a, b$ 同阶，且带上了 $\text{gcd}$ 的 $\text{log}$） 怎么把我们所学的莫比乌斯反演的知识应用上去呢？ 观察一下题目所要求的式子，由于 $(i, j) \not = x$ 的情况对答案无影响，不妨将枚举的 $i, j$ 的意义从“具体数字”变为“是 $x$ 的几倍”。 这样就可以保证 $(ix, jx) = x$， 于是式子变为这样： $$\sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} [(i, j) = 1]$$ 这时候，式子中出现了一个有意思的东西：$[(i, j) = 1]$ 这跟单位元 $\epsilon(n) = [n = 1]$ 的样子不是一模一样吗？ 那么开始化式子： $$\begin{aligned} &amp; \sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} [(i, j) = 1] \\ =&amp; \sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} \epsilon((i, j)) \\ =&amp; \sum_{i = 1}^{\lfloor \frac a x \rfloor} \sum_{j = 1}^{\lfloor \frac b x \rfloor} \sum_{d|(i, j)} \mu(d)\end{aligned}$$ 由 $d|(i, j)$，可知 $d|i$ 且 $d|j$。那么我们可以考虑更换枚举顺序，同时再次更改 $i, j$ 的意义。 先枚举 $d$，再枚举 $i, j$，此时 $i, j$ 的意义再次变为：“是 $xd$ 的几倍”。 于是式子变成这样： $$\begin{aligned} &amp; \sum_d \mu(d) \sum_{i = 1}^{\lfloor \frac a {xd} \rfloor} \sum_{j = 1}^{\lfloor \frac b {xd} \rfloor} 1 \\ =&amp; \sum_d \mu(d) \lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor\end{aligned}$$ 至此，式子就全部化完了，回答询问时间已经从 $O(n^2 \text{log} n)$ 降为了 $O(n)$。（实际观察式子，$O(n)$ 也只是极端情况，很多时候跑不到） 但是因为有多组询问，我们可以运用上面所讲的整除分块的方法，将处理询问的时间优化到 $O(\sqrt n)$。 具体而言，$\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 这两个式子分别都会有自己的不同的分块。 也就是说，对于当前位置 $l$，$a, b$ 都分别有其对应位置 $r_a = \lfloor \frac a {\lfloor \frac a l \rfloor} \rfloor, r_b = \lfloor \frac b {\lfloor \frac b l \rfloor} \rfloor$ 将 $\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 这两个相乘的式子视作整体，那么只有取 $r_a, r_b$ 中最小的（定义为 $r$），才能保证 $[l, r]$ 中 $\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 全部相等。 既然 $\lfloor \frac a {xd} \rfloor \lfloor \frac b {xd} \rfloor$ 已经全部相等，$\mu(d)$ 用一个简单的前缀和累计一下就可以了。 但是这里再次牵扯出来一个问题：如何快速求出 $\mu$？ 因为 $\mu$ 是积性函数，所以我们稍稍改变一下以前学过的线性筛素数的方法，就可以在线性时间内筛出所有 $\mu(i)$ 的值了。 都学莫比乌斯反演了你不要跟我讲你不会线性筛 （其实有比线性筛更优秀的做法，等我学了再补吧233） 具体而言，若当前数是质数，那么 $\mu$ 值为 $-1$； 设用来筛其他数的当前数为 $i$，遍历到的当前质数为 $p$，那么在 $p$ 小于 $i$ 的最小质因子时， $\mu(pi) = -\mu(i)$。 为什么？仔细想想，在遍历到最小质因子之前，当前数和所遍历到的质数一定互质（显然，要不然就和最小质因子矛盾了） 也就是说，$w(pi) = w(i) + 1$。所以有了上述式子。 如果 $p$ 大于等于 $i$ 最小质因子，就不用筛了（线性筛原理） 实现可以看下代码。 以下是整体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-02-16 10:38 * FileName : else.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;typedef long long LL;typedef unsigned int uint;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 5e4 + 2;int T, a, b, x;LL ans;int mu[maxN], premu[maxN];bool vis[maxN];std::vector&lt;int&gt; prim;inline void Shuffle(int n)&#123; premu[1] = mu[1] = 1; for (register int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) prim.push_back(i), mu[i] = -1; for (register uint j = 0; j &lt; prim.size() and prim[j] * i &lt;= n; ++j) &#123; vis[i * prim[j]] = true; if (i % prim[j]) mu[i * prim[j]] = -mu[i]; else break; &#125; premu[i] = premu[i - 1] + mu[i]; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("else.in", "r", stdin); freopen("else.out", "w", stdout);#endif T = read(), Shuffle(maxN - 2); while (T--) &#123; a = read(), b = read(), x = read(), ans = 0; a /= x, b /= x; for (register int l = 1, r; l &lt;= std::min(a, b); l = r + 1) &#123; r = std::min(a / (a / l), b / (b / l)); ans += (premu[r] - premu[l - 1]) * (LL)(a / l) * (b / l); &#125; write(ans), putchar('\n'); &#125; return 0;&#125; 例2 $\text{YY}$ 的 $\text{GCD}$题目大意$T$ 组数据。 给定 $n, m$，求 $$\sum_{i = 1}^n \sum_{j = 1}^m [(i, j) \in \mathbb P]$$ 其中 $\mathbb P$ 表示质数集合。 $T = 10^4, n, m \le 10^7$。 分析（这里设 $n \le m$） 判其是否为质数可能不太好搞，那我们直接在外面枚举质数就行。 式子变成这样： $$\sum_{p \in \mathbb P} \sum_{i = 1}^n \sum_{j = 1}^m [(i, j) = p]$$ 然后和上一题同理： $$\sum_{p \in \mathbb P} \sum_{d} \mu(d) \lfloor \frac{n}{pd} \rfloor \lfloor \frac{m}{pd} \rfloor$$ 然后就可以愉快地做了 然后 T 飞了。复杂度过高，大概是 $O(T |\mathbb P| \sqrt n)$。 对于这种看似最简化的式子，我们需要一个常用的优化技巧： 令 $x = pd$，则 $d = \frac x p$，式子变为： $$\sum_{p \in \mathbb P} \sum_{d = 1}^{\lfloor \frac n p \rfloor} \mu(\frac x p) \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x} \rfloor$$ 再次改变枚举顺序，把 $x$ 提到前面来： $$\sum_{x = 1}^n \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x} \rfloor \sum_{p \in \mathbb P, p | x} \mu(\frac x p)$$ 可以发现 $$\sum_{p \in \mathbb P, p | x} \mu(\frac x p)$$ 这玩意是可以预处理的，线性筛完枚举质数，算其对其倍数的贡献就行。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-02-16 16:13 * FileName : else.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;bitset&gt;#include &lt;vector&gt;typedef long long LL;typedef unsigned int uint;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))#define __bufsize (1 &lt;&lt; 21)char _ibuf[__bufsize], _obuf[__bufsize], _stk[20];char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;struct END&#123; ~END() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; &#125;__;inline int read()&#123; register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch &amp; 15), isdigit(ch = getchar())); return x;&#125;template &lt;typename _INT&gt;inline void write(_INT x)&#123; while (*++stkpos = x % 10 ^ 48, x /= 10, x); while (stkpos != _stk) putchar(*stkpos--);&#125;template &lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template &lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;const int maxN = 1e7;int T, n, m;LL ans;int mu[maxN + 1], F[maxN + 1];std::bitset&lt;maxN + 1&gt; vis;std::vector&lt;int&gt; prim;inline void Shuffle()&#123; mu[1] = 1, prim.reserve(int(6e5)); for (register int i = 2; i &lt;= maxN; ++i) &#123; if (!vis[i]) prim.push_back(i), mu[i] = -1; for (register uint j = 0; j &lt; prim.size() and i * prim[j] &lt;= maxN; ++j) &#123; vis.set(i * prim[j]); if (i % prim[j]) mu[i * prim[j]] = -mu[i]; else break; &#125; &#125; for (register uint i = 0; i &lt; prim.size(); ++i) for (register int j = 1; prim[i] * j &lt;= maxN; ++j) F[prim[i] * j] += mu[j]; for (register int i = 2; i &lt;= maxN; ++i) F[i] += F[i - 1];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("else.in", "r", stdin); freopen("else.out", "w", stdout);#endif T = read(), Shuffle(); while (T--) &#123; n = read(), m = read(), ans = 0; if (n &gt; m) std::swap(n, m); for (register int l = 1, r; l &lt;= n; l = r + 1) &#123; r = std::min(n / (n / l), m / (m / l)); ans += LL(F[r] - F[l - 1]) * (n / l) * (m / l); &#125; write(ans), putchar('\n'); &#125; return 0;&#125; $\huge \text{To be continued…}$]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu]Tweetuzki爱序列]]></title>
    <url>%2FLuogu-Tweetuzki%E7%88%B1%E5%BA%8F%E5%88%97.html</url>
    <content type="text"><![CDATA[前言题面传送门: Luogu-5080 洛咕里面有人发了跟我类似的题解了- - 用这篇题解来纪念我想出来但是打挂成 $50$ 的 $100pts$ 题目描述给定序列 $a_1, a_2, \dots a_n$. 在原数列中任取 $k$ 个数, 排列组合成 $b_1,b_2, \dots b_k$, 使得 $$\forall i \in [1,k), b_i=2b_{i-1}\ or\ b_i=\frac{b_{i-1}}{3}(3|b_{i-1})$$ $(3|b_{i-1} \Longleftrightarrow b_{i-1}\ \text{mod}\ 3=0)$ 求出最大的 $k$, 并输出这个序列. $n \le 10^5, 3 \le a_i \le 10^{18}$. Special Judge. 题目分析很容易想到的是将这个数向可接上的所有数连上一条有向边. 也就是说: 12345for i:=1...n if(a[i] * 2存在) Link(i, a[i] * 2所在位置) if(a[i] % 3 == 0 &amp;&amp; a[i] / 3存在) Link(i, a[i] / 3所在位置) 这样子就得出了一张图. 对其求最长路即可. 但这样就出现了问题: 时空复杂度怎么保证? 见下文中的时空复杂度分析. 最长路不是NP问题吗? 实际上, 可以证明我们得出的图是一张DAG(有向无环图). 证明过程如下: 首先, 图是有向图. 证明其无环即可. 考虑反证法, 假设有向图中有环. 设 $i$ 为环上某一节点, $len$ 为环长度. 则必有: $$a_i \cdot (\frac{1}{3})^x \cdot 2^y=a_i \\x,y \in N_+, x+y=len$$ 约去 $a_i$, 整理: $$2^y=3^x$$ 对等式两边取以 $2$ 为底的对数, 整理:$$\frac{y}{x}= \text{log}_2 3$$ 可知 $\text{log}2 3$ 为无理数, 又 $x,y \in N+$, 故 $x,y$ 无解, 与假设矛盾, 故不成立. 证毕. 这样就变成了一个DAG上的最长链问题了, 拓扑排序中DP一下即可. 时空复杂度分析由刚才的证明, 我们可以进一步得出一个结论: $a_i$ 重复对答案没有帮助, 可以直接去重. 这个也很好证，因为无环, 一个数无论如何变化都不会变化回自己了, 所以有多少个都没有用. 观察刚刚的伪代码, 因为 $a_i$ 可以去重, 那么每个节点至多连接两条有向边(实际连边还会更少), 所以可知空间复杂度为 $O(n)$; 而DAG的最长链显然是 $O(n)$ 的. 加上前面连边时 $O(n \text{log} n)$ 的复杂度(确认数是否存在需要 $O(\text{log} n)$哈希的话当我没说) 总时间复杂度为 $O(n \text{log} n)$. 实现细节 可以用std::map判断数存不存在. 我用的是std::tr1::unordered_map. 因边数不确定, 可以用std::vector存图. 读入和输出数据都较大, 请避免使用未关同步的std::cin和std::cout. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2018-12-12 20:53 * FileName : new.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;tr1/unordered_map&gt;typedef long long LL;class Istream&#123; char *ipos;public : Istream() &#123;#ifndef ONLINE_JUDGE freopen("new.in", "r", stdin); freopen("new.out", "w", stdout);#endif ipos = (char*)mmap(NULL, lseek(0, 0, SEEK_END), PROT_READ, MAP_PRIVATE, 0, 0); &#125; Istream&amp; operator&gt;&gt;(int&amp; n) &#123; n = 0; while(!isdigit(*ipos)) ++ipos; while(n = (n &lt;&lt; 3) + (n &lt;&lt; 1) + (*ipos++ &amp; 15), isdigit(*ipos)); return *this; &#125; Istream&amp; operator&gt;&gt;(LL&amp; n) &#123; n = 0; while(!isdigit(*ipos)) ++ipos; while(n = (n &lt;&lt; 3) + (n &lt;&lt; 1) + (*ipos++ &amp; 15), isdigit(*ipos)); return *this; &#125;&#125; in;char _obuf[1 &lt;&lt; 20], _stk[20];class Ostream&#123; char *opos, *oend, *stkpos;public : Ostream() &#123; oend = (opos = _obuf) + (1 &lt;&lt; 20) - 1; stkpos = _stk; &#125; ~Ostream() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; void Putchar(char ch) &#123; *opos = ch; if(opos == oend) &#123; fwrite(_obuf, 1, 1 &lt;&lt; 20, stdout); opos = _obuf; &#125; ++opos; &#125; Ostream&amp; operator&lt;&lt;(int n) &#123; do &#123; *++stkpos = n % 10 ^ 48; n /= 10; &#125; while(n); while(stkpos != _stk) Putchar(*stkpos--); return *this; &#125; Ostream&amp; operator&lt;&lt;(LL n) &#123; do &#123; *++stkpos = n % 10 ^ 48; n /= 10; &#125; while(n); while(stkpos != _stk) Putchar(*stkpos--); return *this; &#125; Ostream&amp; operator&lt;&lt;(char c) &#123; Putchar(c); return *this; &#125;&#125; out;template&lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;template&lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;const int maxN = 1e5 + 2;int ind[maxN]/*indegree*/, F[maxN], pre[maxN];LL a[maxN];std::vector&lt;int&gt; G[maxN];std::queue&lt;int&gt; q;std::stack&lt;int&gt; stk;std::tr1::unordered_map&lt;LL, int&gt; MAP;int main()&#123; register int n, k = 0, pos/*position*/, u, v; in &gt;&gt; n; for(register int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; a[i]; MAP[a[i]] = i; &#125; for(register int i = 1; i &lt;= n; ++i) &#123; if(MAP.count(a[i] &lt;&lt; 1)) &#123; G[i].push_back(MAP[a[i] &lt;&lt; 1]); ++ind[MAP[a[i] &lt;&lt; 1]]; &#125; if(a[i] % 3 == 0 and MAP.count(a[i] / 3)) &#123; G[i].push_back(MAP[a[i] / 3]); ++ind[MAP[a[i] / 3]]; &#125; &#125; for(register int i = 1; i &lt;= n; ++i) if(!ind[i]) &#123; q.push(i); F[i] = 1; &#125; while(!q.empty()) &#123; u = q.front(); q.pop(); for(register unsigned int i = 0; i &lt; G[u].size(); ++i) &#123; v = G[u][i]; if(Chkmax(F[v], F[u] + 1)) pre[v] = u; --ind[v]; if(!ind[v]) q.push(v); &#125; &#125; for(register int i = 1; i &lt;= n; ++i) if(Chkmax(k, F[i])) pos = i; out &lt;&lt; k &lt;&lt; '\n'; for(register int i = pos; i; i = pre[i]) stk.push(i); while(!stk.empty()) &#123; out &lt;&lt; a[stk.top()] &lt;&lt; ' '; stk.pop(); &#125; return 0;&#125; $\huge\text{Thanks for your consideration!}$]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DAG</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板]普通平衡树]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF-%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91.html</url>
    <content type="text"><![CDATA[$\text{Foreword}$To be continued. 本文代码均为指针版. 本文中所说的平衡树指的均是二叉平衡树. 本文中所说的中序遍历指的均是左中右顺序. 题面传送门: Luogu-P3369 前言平衡树板子. 给定 $n$ 次操作, 有且仅有下面6种操作: 插入 $x$. 删除 $x$ (若有多个相同的, 只删除一个). 查询 $x$ 的排名(排名定义: 比当前数小的数的个数+1. 若有多个相同的数, 输出最小的排名). 查询排名为 $x$ 的数. 求 $x$ 的前驱(前驱定义: 大于 $x$ 的最小的数) 求 $x$ 的后继(后继定义: 小于 $x$ 的最大的数) $n \le 10^5,x \in [-10^7,10^7]$. 保证操作合法. 题解平衡树基础之BST(注: 如果你对下文内容看的不是非常明白, 请回来点击这里, 自己操作一番, 可以加深理解) 要学习平衡树, 你首先需要了解二叉查找树(Binary Search Tree, BST). BST定义 树中每个节点都被赋予了一个权值;(这里先假设权值互不相同) 若左子树非空, 则左子树上所有节点的值均小于其根节点的值; 若右子树非空, 则右子树上所有节点的值均大于其根节点的值. 举个例子: 这就是一棵二叉查找树. 看看这张图, 是不是正如我说的一样? 对于66号节点, 左子树中分别为1,19,23,45,54,59, 全部小于66; 右子树中分别为71,77,91, 全部大于66. 对于19号节点, 左子树中分别为1, 全部小于19; 右子树中分别为23,45,54,59, 全部大于19. 现在大致明白了这种神奇的树了吧? 这里给出一个性质: 二叉查找树的中序遍历是一个有序序列. 可以自己动手试一试画一画, 也可以用程序: 12345678910111213141516171819typedef struct Node* ptr; // 将ptr作为Node*这种类型的别称struct Node&#123; int val; ptr left, right; Node(int val) : val(val) // 构造函数, 初始化新节点的左右儿子为空, 值为val &#123; left = right = NULL; &#125;&#125; *root;void Print_Mid(ptr curr_node) // 中序遍历输出&#123; if(!curr_node) // !可用于判断空指针 return; Print_Mid(curr_node-&gt;left); printf("%d\n", curr_node-&gt;val); Print_Mid(curr_node-&gt;right);&#125; 几个基本操作查找特定的值123456789inline ptr Find(int x, ptr curr_node) // 在以curr_node为根的子树中找到值为x的节点&#123; while(curr_node-&gt;val != x) if(x &lt; curr_node-&gt;val) curr_node = curr_node-&gt;left; else curr_node = curr_node-&gt;right; return curr_node;&#125; 利用的还是二叉查找的思想. 查找最值12345678910111213inline ptr Find_Min(ptr curr_node) // 在以curr_node为根的子树中找到最小值&#123; while(curr_node-&gt;left) // 判断左子节点是否存在 curr_node = curr_node-&gt;left; return curr_node;&#125;inline ptr Find_Max(ptr curr_node) // 在以curr_node为根的子树中找到最大值&#123; while(curr_node-&gt;right) curr_node = curr_node-&gt;right; return curr_node;&#125; 同理, 根据二叉查找树的性质可以得出. 插入节点12345678910inline void Insert(int x) // 插入值为x的节点&#123; register ptr curr_node = root; while(curr_node) if(x &lt; curr_node-&gt;val) curr_node = curr_node-&gt;left; else curr_node = curr_node-&gt;right; curr_node = new Node(x);&#125; 同查找节点, 找到适合位置之后新建节点即可. 但是, 上述代码是完全错误的. 如果细心观察会发现: curr_node的改变, 不影响原值. 上述代码所犯错误跟这段代码差不多: 123ptr p = root;p = NULL;// root == NULL? False. p值的修改是不可能影响到root的. 这个例子应该好懂了些吧? 正确代码如下: 123456789101112131415161718192021222324252627282930inline void Insert(int x) // 插入值为x的节点&#123; if(!root) &#123; root = new Node(x); return; &#125; register ptr curr_node = root; while(true) &#123; if(x &lt; curr_node-&gt;val) &#123; if(!curr_node-&gt;left) &#123; curr_node-&gt;left = new Node(x); return; &#125; curr_node = curr_node-&gt;left; &#125; else &#123; if(!curr_node-&gt;right) &#123; curr_node-&gt;right = new Node(x); return; &#125; curr_node = curr_node-&gt;right; &#125; &#125;&#125; 相当于改成这样: 123ptr p = root;p-&gt;left = NULL;// root-&gt;left == NULL? True. 从直接修改当前节点变成了修改当前节点的子节点, 保证了不会出现引用啥啥乱七八糟的问题. 删除节点这里较为复杂. 首先找到该节点, 然后分三种情况讨论 该节点是叶节点. 直接删除. 该节点是链节点(只有一个儿子). 用这个儿子代替它的位置就行. 该节点非叶非链. 这种情况复杂一点, 一般是找到它的后继代替他的位置然后删掉后继. 显然,它的后继一定为链节点或叶节点, 删除后继很好删除. 再用一下上面的图 现在我们要删除19, 只需要找到它的后继23, 将19这个节点的值赋为23后删除23节点即可. (顺便说一句: 有一个23没有变成23是有意义的, 23是特指节点, 23指的是二十三这个数字.) 1234567891011121314151617181920inline void Simple_Delete(ptr&amp; curr_node) // 对应1, 2情况的节点删除&#123; if(curr_node-&gt;left) curr_node = curr_node-&gt;left; else curr_node = curr_node-&gt;right;&#125;inline void Delete(int x) // 删除值为x的节点&#123; ptr curr_node = Find(x, root); if(curr_node-&gt;left and curr_node-&gt;right) &#123; ptr temp = Find_Min(curr_node-&gt;right); curr_node-&gt;val = temp-&gt;val; Simple_Delete(temp); &#125; else Simple_Delete(curr_node);&#125; 然而同样的 代码完全错误- - 请读者自行思考如何写出正确删除操作 一些小提示: Find函数返回值并未引用. 可以像Insert函数的改正一样, 对当前节点的子节点进行操作, 而不是对当前节点操作. 牺牲一小点效率, 写成递归形式.(这样对于参数的引用就非常好处理) 偷个懒, 这个代码就不放了- - 如果实在想不出来, 可以参照下面的Splay中的非递归形式和Treap中的递归形式. 前驱后继定义请参照题面. 要注意的是, 所查询元素可以不是当前树中的元素. 即如果现在树中有1, 22, 333个节点, 我可以查询24的后继(33)和前驱(22). 两个操作差不多, 就只讲后继了. 在find操作里面加点零件就可以了. 定义ret为从根节点走到目前节点为止, 比所查询元素大的最小的元素. 如果当前节点的值大于所查询元素, 更新ret为当前节点的值, 往左子树走; 如果当前节点的值小于所查询元素, 直接往右子树走就行. 原理自己想去 前驱操作把左右和大于小于倒过来就差不多了. 代码: 1234567891011121314151617181920212223242526272829303132333435inline int Pre/*predecessor*/(int val)&#123; register ptr curr = root; register int ret; while(curr) &#123; if(val &gt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; return ret;&#125;inline int Suc/*successor*/(int val)&#123; register ptr curr = root; register _val ret; while(curr) &#123; if(val &lt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[0]; &#125; else curr = curr-&gt;son[1]; &#125; return ret;&#125; 基本操作就讲这么多. 排名相关然而… ??? 题目中的3,4操作呢? 别急. 刚刚讲的是最基础的BST, 真正要支持查询排名节点还需要维护一个东西, 叫size. 这题因为有可重复元素, 还要维护一个东西, 叫cnt. 分别解释一下: size表示以当前节点为根的子树中节点的个数(包含重复元素). cnt表示当前节点有多少个重复元素.(就是val一样, 然后累在一起) 给个定义不够清楚, 还是上刚刚那个图 66的size是10, 19的size是6, 91的size是3, 45的size是4, 77的size是1, 等等. 这图里面元素不重复, 所以cnt没有体现 如果我现在插入19, 它就不会新建节点, 而是使19的cnt++(同时, 19和66的size也会++). 维护了size域之后, 我们就可以着手做3,4操作了 基础思想是分治. 首先可以知道的是, 在一棵子树中, 根节点的排名大小取决于左子树的size. 可以得出, 根节点的权值在这棵子树中的排名是一个闭区间: $[lsize+1,lsize+cnt]$. (为什么说是一个区间, 因为有重复元素. 题目里面明确讲了取最小排名.) (其中 $lsize$ 是左儿子的节点个数, $cnt$ 是当前节点的cnt) 依据这个原理, 分别来做3,4操作: 查询排名第 $k$ 的元素其实排名为 $k$ 就是查找 $k$ 小. 因为BST的中序遍历有序, 所以, 如果将一个BST执行中序遍历, 比当前节点小的数的个数就是左子树的size(这句话需要好好理解一下). 总共三种情况: $lsize &lt; k \le lsize + cnt$ 要查找元素就是当前元素, 直接return即可. $k \le lsize$ 说明要查找的节点在左子树中, 并且在左子树中还是排名第 $k$ (结合我前面说的, 想想为什么). 在左子树继续查找即可. $k&gt;lsize+cnt$ 说明要查找的节点在右子树中, 并且在右子树的排名为 $k-lsize-cnt$ (同样结合我前面那一句话, 想想为什么). 将 $k$ 减去对应值之后再在右子树查找即可. 代码如下: 1234567891011121314151617181920inline int QK/*Query Kth*/(int k)&#123; register ptr curr = root; register int size; while(curr) &#123; size = Size(curr-&gt;son[0]); if(k &gt; size and k &lt;= size + curr-&gt;cnt) return curr-&gt;val; if(k &lt;= size) curr = curr-&gt;son[0]; else &#123; k -= size + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; &#125; assert(false); // 正常的话会在while循环里面就return掉了, 如果执行到这里说明程序挂了, 这个指令会自动RE&#125; 查询元素排名(本题中保证所查询的元素现在一定存在). 这和上述查找 $k$ 小的操作非常类似, 可以近似认为是互逆运算(其实它更好理解一些). 过程和find差不多, 但是需要额外定义一个k, 表示从根节点遍历到目前为止, 比所查询元素大的元素个数(初始化为0). 在find的过程中, 如果你需要往左走, 对于k值是无影响的; 而如果要往右走, 则k需要加上左子树的size和当前节点的cnt. 结合代码理解一下(最后k还加上一个值, 是因为比查找到的节点小的数也包括了其左子树的size, 而在循环中是没有加上的): 123456789101112131415161718inline int QR/*Query Rank*/(int val)&#123; register ptr curr = root; register int k = 0; while(curr-&gt;val != val) &#123; if(curr-&gt;val &lt; val) &#123; k += Size(curr-&gt;son[0]) + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; k += Size(curr-&gt;son[0]) + 1; return k;&#125; 平衡树引入经过刚刚的一通乱讲说明, 这道题已经可以做了, 但时间复杂度还无法保证. 非常显然,BST各个操作的时间复杂度均为 $O(h)$. 其中 $h​$ 为二叉搜索树的高度. 然而BST极其可能会退化成一条链, 或者说树深度过深, 导致 $h$ 趋近于 $n$, 显然每个操作 $O(n)$ 的复杂度是我们无法接受的. 这个时候, 就需要我们的平衡树来救场了. 其实平衡树的本质就是BST加上调整. 调整一般有几种(OI用): 旋转, 重构, 分裂合并. 典型的代表就是 Splay, 替罪羊树, fhq Treap. SplaySplay是平衡树的一种. 由Tarjan和Daniel Sleator开发.(感觉信息这方面哪里都能看见Tarjan…) 它的核心操作只有一个:Splay(顾名思义, 伸展操作). 节点定义Splay本质而言还是一棵树, 我们要先确定其节点要存放什么东西. 相对BST的节点要存的东西其实也没多多少, 只是多了一个父指针指向父亲而已. (其实也有递归实现的无父指针版, 如果想学可以参考这里) 先留个坑- -放个代码在这里2333 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2018-12-11 19:26 * FileName : new.cpp * Website : https://endsah.cf * *******************************************************/#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cassert&gt;class Istream&#123; char *ipos;public : Istream() &#123;#ifndef ONLINE_JUDGE freopen("new.in", "r", stdin); freopen("new.out", "w", stdout);#endif ipos = (char*)mmap(NULL, lseek(0, 0, SEEK_END), PROT_READ, MAP_PRIVATE, 0, 0); &#125; Istream&amp; operator&gt;&gt;(int&amp; n) &#123; register bool flag = false; n = 0; while(!isdigit(*ipos)) &#123; if(*ipos == '-') flag = true; ++ipos; &#125; while(n = (n &lt;&lt; 3) + (n &lt;&lt; 1) + (*ipos++ &amp; 15), isdigit(*ipos)); if(flag) n = -n; return *this; &#125;&#125; in;char _obuf[1 &lt;&lt; 20], _stk[20];class Ostream&#123; char *opos, *oend, *stkpos;public : Ostream() &#123; oend = (opos = _obuf) + (1 &lt;&lt; 20) - 1; stkpos = _stk; &#125; ~Ostream() &#123; fwrite(_obuf, 1, opos - _obuf, stdout); &#125; void Putchar(char ch) &#123; *opos = ch; if(opos == oend) &#123; fwrite(_obuf, 1, 1 &lt;&lt; 20, stdout); opos = _obuf; &#125; ++opos; &#125; Ostream&amp; operator&lt;&lt;(int n) &#123; if(n &lt; 0) &#123; Putchar('-'); n = -n; &#125; do &#123; *++stkpos = n % 10 ^ 48; n /= 10; &#125; while(n); while(stkpos != _stk) Putchar(*stkpos--); return *this; &#125; Ostream&amp; operator&lt;&lt;(char c) &#123; Putchar(c); return *this; &#125;&#125; out;template&lt;typename _Tp&gt;inline bool Chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? x = y, true : false; &#125;template&lt;typename _Tp&gt;inline bool Chkmax(_Tp&amp; x, const _Tp&amp; y)&#123; return x &lt; y ? x = y, true : false; &#125;template&lt;typename _val&gt;struct Splay_Node&#123; typedef Splay_Node &lt;_val&gt;* ptr; ptr son[2], fa; _val val; int size, cnt; Splay_Node(const _val&amp; val, ptr fa) : val(val), fa(fa) &#123; size = cnt = 1; son[0] = son[1] = NULL; &#125;&#125;;template&lt;typename _val&gt;class Splay_Tree&#123; typedef Splay_Node &lt;_val&gt;* ptr; ptr root; public : Splay_Tree() &#123; root = NULL; &#125; int Ident/*Identify*/(ptr x) &#123; return x-&gt;fa == NULL ? 0 : x-&gt;fa-&gt;son[1] == x; &#125; int Size(ptr x) &#123; return x == NULL ? 0 : x-&gt;size; &#125; void Update(ptr x) &#123; x-&gt;size = Size(x-&gt;son[0]) + Size(x-&gt;son[1]) + x-&gt;cnt; &#125; void Link(ptr fa, ptr son, int dir/*direction*/) &#123; if(!fa) root = son; else fa-&gt;son[dir] = son; if(son) son-&gt;fa = fa; &#125; void Rotate(ptr x) &#123; register ptr fa = x-&gt;fa; register int dir = Ident(x); Link(fa-&gt;fa, x, Ident(fa)); Link(fa, x-&gt;son[dir ^ 1], dir); Link(x, fa, dir ^ 1); Update(fa); &#125; void Splay(ptr x, ptr goal) &#123; register ptr fa; while(x-&gt;fa != goal) &#123; fa = x-&gt;fa; if(fa-&gt;fa == goal) &#123; Rotate(x); break; &#125; if(Ident(fa) ^ Ident(x)) Rotate(x); else Rotate(fa); Rotate(x); &#125; Update(x); &#125; void Insert(const _val&amp; val) &#123; if(!root) &#123; root = new Splay_Node&lt;_val&gt;(val, NULL); return; &#125; register ptr curr = root; register int dir = val &gt; curr-&gt;val; while(true) &#123; ++curr-&gt;size; if(curr-&gt;val == val) &#123; ++curr-&gt;cnt; return; &#125; dir = val &gt; curr-&gt;val; if(curr-&gt;son[dir]) curr = curr-&gt;son[dir]; else &#123; curr-&gt;son[dir] = new Splay_Node&lt;_val&gt;(val, curr); Splay(curr-&gt;son[dir], NULL); return; &#125; &#125; &#125; void Delete(const _val&amp; val) &#123; register ptr curr/*current*/ = root, pre/*predecessor*/; while(curr-&gt;val != val) curr = curr-&gt;son[val &gt; curr-&gt;val]; Splay(curr, NULL); if(curr-&gt;cnt &gt; 1) &#123; --curr-&gt;cnt, --curr-&gt;size; return; &#125; pre = curr-&gt;son[0]; if(pre) &#123; while(pre-&gt;son[1]) pre = pre-&gt;son[1]; Splay(pre, curr); root = pre; root-&gt;fa = NULL, root-&gt;son[1] = curr-&gt;son[1]; if(root-&gt;son[1]) &#123; root-&gt;son[1]-&gt;fa = root; root-&gt;size += root-&gt;son[1]-&gt;size; &#125; &#125; else &#123; root = curr-&gt;son[1]; if(root) root-&gt;fa = NULL; &#125; delete curr; &#125; int QR/*Query Rank*/(const _val&amp; val) &#123; register ptr curr = root; register int k = 0; while(curr-&gt;val != val) &#123; if(curr-&gt;val &lt; val) &#123; k += Size(curr-&gt;son[0]) + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; k += Size(curr-&gt;son[0]) + 1; Splay(curr, NULL); return k; &#125; _val QK/*Query Kth*/(int k) &#123; register ptr curr = root; register int size; while(curr) &#123; size = Size(curr-&gt;son[0]); if(k &gt; size and k &lt;= size + curr-&gt;cnt) return curr-&gt;val; if(k &lt;= size) curr = curr-&gt;son[0]; else &#123; k -= size + curr-&gt;cnt; curr = curr-&gt;son[1]; &#125; &#125; assert(false); &#125; _val Pre(const _val&amp; val) &#123; register ptr curr = root; register _val ret; while(curr) &#123; if(val &gt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[1]; &#125; else curr = curr-&gt;son[0]; &#125; return ret; &#125; _val Suc/*successor*/(const _val&amp; val) &#123; register ptr curr = root; register _val ret; while(curr) &#123; if(val &lt; curr-&gt;val) &#123; ret = curr-&gt;val; curr = curr-&gt;son[0]; &#125; else curr = curr-&gt;son[1]; &#125; return ret; &#125;&#125;;int main()&#123; register int n, opt, x; Splay_Tree&lt;int&gt; wib; in &gt;&gt; n; while(n--) &#123; in &gt;&gt; opt &gt;&gt; x; switch(opt) &#123; case 1 : wib.Insert(x); break; case 2 : wib.Delete(x); break; case 3 : out &lt;&lt; wib.QR(x) &lt;&lt; '\n'; break; case 4 : out &lt;&lt; wib.QK(x) &lt;&lt; '\n'; break; case 5 : out &lt;&lt; wib.Pre(x) &lt;&lt; '\n'; break; case 6 : out &lt;&lt; wib.Suc(x) &lt;&lt; '\n'; break; &#125; &#125;&#125; TreapTreap是一种相对较为随机的平衡树. 具体来说, 就是对每个节点赋一个优先级. 保证不破坏其二叉查找树的本质的同时, 使节点按所赋的优先级排为堆序. 继续留坑(代码比较丑, 到时候重写一下再放上来)]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2007]报表统计]]></title>
    <url>%2FZJOI2007-%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1.html</url>
    <content type="text"><![CDATA[前言题面传送门: Luogu-P1110. 本文中使用的是set &amp;&amp; multiset, 并非平衡树. 洛咕题解第一篇和我的思路撞到一起了. 但好歹是我自己想出来的比较玄学的做法 写写题解记录记录2333 题目描述给你一个长度为 $n$ 的非负整数序列. 总共有以下三种操作: INSERT i k: 在原数列的第 $i$ 个元素后添加一个新元素 $k$. MIN_GAP: 查询相邻两元素之间差值(绝对值)的最小值. MIN_SORT_GAP: 查询所有元素中数值大小最接近的两个元素的差值(绝对值). 共 $m$ 次操作, $n,m \le 500000$. 题目分析初步思路首先要注意到INSERT操作是在原数列的元素后插入. 举个例子: 原数列为: $\lbrace 5,3,1 \rbrace$ 现在INSERT 2 9 对应结果: $\lbrace 5,3,9,1 \rbrace$ 再INSERT 2 4 对应结果: $\lbrace 5,3,9,4,1 \rbrace$ 相当于原数列的每个数挂了条链表. 3操作倒是很好搞, 跟这道题差不多, 搞一个set, 每次插入数的时候用其与前驱和后继的差值更新答案即可. 重点在1,2操作. 暴力优先考虑暴力一点的做法: 设原数列每个元素为 $a_{1 \cdots n}$. 先把所有的 $|a_i-a_{i+1}|$ 丢到multiset里面. INSERT操作的时候, 对于给出的 $i$, 把 $|lsta_i-a_{i+1}|$ 删掉 (其中 $lsta_i$ 表示 $a_i$ 所挂的链的最后一个数) 加入 $|k-lsta_i|,|k-a_{i+1}|$ 每次查询输出*multiset.begin(). 在这个思想的基础上, 原本麻烦的INSERT操作也免了 因为在 $a_i$ 挂上的一条链中, 我们只需要用到 $lsta_i$ 直接用另一个数组维护一下就可以了. 复杂度这是不是太暴力了? 思考一下时间复杂度. $m$ 次操作, 每次操作均摊下来是 $O(logn)$. 总时间复杂度即 $O(mlogn)$, 可以通过本题. 实现细节 注意set的边界问题. 实在不想处理可以一开始就插入INF &amp;&amp; -INF. 注意维护 $lsta_i$ 的数组的初值赋为 $a_i$. 当 $i=n$, $a_{i+1}$ 是不存在的. (可能只有我一个人犯的错误) 用fread用惯之后在这个题写了个字符串读入, 然后写挂了, 交上去全TLE… 搞得我怀疑了半天人生 最后只好用getchar读优 然而不开O2最后一个点好像死活过不去… 可能我的常数不够优秀吧 若使用multiset.erase(val), 则multiset会删除键值等于val的所有元素.所以需要multiset.erase(multiset.find(val))来删除单个的迭代器. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2018-11-26 19:10 * FileName : wib.cpp * Website : endsah.cf * *******************************************************/#include &lt;cstdio&gt;#include &lt;set&gt;template&lt;typename _Tp&gt;inline bool chkmin(_Tp&amp; x, const _Tp&amp; y)&#123; return x &gt; y ? (x = y, true) : false; &#125;template&lt;typename _Tp&gt;inline _Tp abs(const _Tp&amp; x)&#123; return x &lt; 0 ? -x : x; &#125;const int maxN = 5e5 + 2;const int INF = 0x7FFFFFFF;int n, m, sort_ans = INF, ans = INF, temp, last;int a[2][maxN];std::set&lt;int&gt; SET1;std::multiset&lt;int&gt; SET2;std::set&lt;int&gt;::iterator it;char opt[15];inline void Check(int val)&#123; if(!SET1.empty()) &#123; it = SET1.lower_bound(val); if(it != SET1.end()) &#123; chkmin(sort_ans, *it - val); if(it != SET1.begin()) chkmin(sort_ans, val - *--it); &#125; else chkmin(sort_ans, val - *--it); &#125; SET1.insert(val);&#125;inline void Insert(int pos, int val)&#123; SET2.insert(abs(val - a[1][pos])); if(pos != n) &#123; SET2.insert(abs(val - a[0][pos + 1])); SET2.erase(SET2.find(abs(a[1][pos] - a[0][pos + 1]))); &#125; a[1][pos] = val;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(register int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;temp); Check(temp); if(i != 1) SET2.insert(abs(temp - last)); a[0][i] = a[1][i] = last = temp; &#125; while(m--) &#123; scanf("%s", opt); switch(opt[4]) &#123; case 'R' : scanf("%d%d", &amp;temp, &amp;last); Insert(temp, last); Check(last); break; case 'S' : printf("%d\n", sort_ans); break; case 'G' : printf("%d\n", *SET2.begin()); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2FNOIP2018%E6%B8%B8%E8%AE%B0.html</url>
    <content type="text"><![CDATA[转眼间, 人生第一次NOIP就结束了. 成绩并不让人满意, 但是为了记录下自己的OI历程以及警醒以后的自己, 遂写下此文, 期望能够有所感悟和改进. Day -31初赛考完了之后过了两周, 信息组正式宣布停课. 早就迫不及待了. 因此也逃过了期中考试 每天上午考试, 下午讲题, 晚上改题+自练, 循环往复, 周而复始. 但是我们考的比赛是NOI Professional… 完全超过了提高组的考点了好吗 就这样, 习惯于被高二和本届dalao暴踩, NOIP也越来越近… Day 0上午搞了个联赛总动员, 大致意思就是鼓励大家调整心态 然后这一下午和晚上都放了假. 晚上就跑去看了一下毒液.(事实证明考前跑去看电影好像对心态平复不利…) 11:00躺到床上, 一直心绪不宁, 到12:30才勉强睡着… 毕竟是第一次考联赛, 况且考不好就会变成最后一次emm 还是挺紧张的 Day 16:20爬起来, 去食堂匆匆吃了个早饭, 7:10左右车子就出发了. 到地方的时候才7:40左右, 考场还得等半个小时才开, 百无聊赖的站了半个小时. 看到4个国集dalao在旁边说话, 被他们的气场震得瑟瑟发抖 8:10放进考场, 调了会vimrc之后就发密码了. (当时根本不知道飞雪连天是什么意思…) 首先看了一下T1, $O(nlogn)$ 线段树解法??? 大致看一下没什么特别好的思路, 把T2和T3都看了一遍 大凯的疑惑??? 二分答案+树形DP??? 除了T3部分分之外感觉都十分不可做, 又滚回来肝T1 想了半个小时没个结果, 只想出个70分的暴力…打完就走了 又去肝T2, 因心态已经有点爆炸(T1都打不全, T2T3没一点思路), 心里特别乱, 连大样例都没有手推, 凭空往数论方面想了好久…自然是什么都打不出来(当时我还认为T2是个省选/NOI-) 到放弃T2再看T3, 心态已经完全炸了. 思路杂乱自然什么都做不了, 又想着想正解又想着部分分怎么拿, 于是T3正解也没想出来, $a_i=1$ 的部分分也没有拿, 匆匆拿了个40就走了. 滚回去看T2, 这时候已经10:20了… 当时是有点绝望了 看了一眼T2的大样例, 我突然有个大胆的猜想: b绝对是a的子集? 又想了五分钟, 想到了筛法 手推了三组样例, 发现是对的时候, 心态有所恢复- - 打了个复杂度极高的筛法, 一发过了大样例. 于是期望得分+=80. 这时候11:00了都… 然后在T1和T3之间一直徘徊…两题都没思路 后来就调自己T3的部分分, 确保有40之后就放弃了. 于是D1期望得分70+80+40=190. 当时因为在绝境中打出了T2的80分, 所以出考场的时候心态还算平静 出去一交流: 我: 你们今天打的怎么样? zqr: T1 100, T2 80, T3 40, 大概220吧. 我: WA TQL! T1你怎么打出来的? zqr: 套个线段树乱搞, 过了 $10^5$ 的大样例233 wzr: 啊? T1不是2013的原题吗? 在洛咕上好像是普及-吧 还有T3不是能骗55分吗? $a_i=1$ 挺好写的啊 我&amp;zqr:……. 于是乎 心态再次爆炸 下午回去自测, 洛咕数据比较水, T1有80, T2直接满了(后来洛谷加了个最毒瘤的重测卡成了95), T3如预期拿到了40 还好没有挂分, 只能祝自己Day2 rp++了… 和我爸出去吃了个饭, 随便晃晃, 回机房的时候都20:30了 我们机房(都是新学4个月的人)有个AK的神仙 orz 没再复习了 注重于调整心态(实际上没什么用) 晚上依然睡不着觉 0:00勉强睡着 Day 2和昨天上午一样, 准时出发, 7:45到了. 又等了好久才放进考场. 进去重配了vimrc, 然后 笑书神侠?? 啥玩意?? 并不理解其中意义, 抓紧时间看题面 果然如他们所言, D2难度上了个档次T1看完题面, ??? 这是能做的??? 看到 $m=n-1\ or\ m=n$ 才放心- - 在看一眼T2 题意都看的不是很明白…果断放弃 T3 特别迷… 又是个树形DP吗… 哪有DP这样子带修改的… (出考场才反应出来是动态DP) 这怕是我们考的NOI Professional的难度 转回T1, 10min打完了60, 心态良好 然后开始搞基环树的40分 这中间折腾了一个小时, 想出一个时间复杂度非常优秀的做法 $O(nlogn)$ 后来我的分数告诉我 我看错题意了 我没怎么深刻理解题意 直接当做一条边可以走两次 实际上有个非常重要的东西 …, 走向一个没有去过的城市, … 当时打上去调了半小时过了大样例, 试了组极限数据保证不TLE之后就欢天喜地的扔掉了T1 继续看T2 觉得十分不可做 部分分都没看就看T3去了 然后依然没有任何头绪… 做过原题都想不起来… 浪费一个小时毫无建树… 心态爆炸.jpg 之后连 $O(n!)$ 的暴力 $20pts$ 都不想打了 直接扔掉了这道题 11:20左右才又开始看T2… 看到 $n \le 2$ 的部分分的时候已经11:40了 只把 $n,m \le 3$ 的数据打了(实际上只打了一部分 $n=2,m=3\ or\ n=3,m=2$ 这部分没时间推了…) 出考场的时候心态已经完全崩了 预计得分100+15+0=115 因为我没有在T2上花什么时间 想不出来很正常 所以我最怕出考场的时候出现这种对话: 我: 打的怎么样? zqr: 60+100+44=204吧 当时脑子里觉得可能会出现这种情况 心态已经完全爆炸了 交流了下发现没有… T2都不会写 暂且松了口气 回去自测才发现T1挂了…挂掉30 T2 15分, T3 0分 预估的最低得分是70+80+40+72+10+0=272 完全绝望 大致和同学聊了一会 我已经快垫底了 GC神仙400+了已经…同是新人为什么我这么菜呢… 事已至此, 再怎么做都无法挽回了 于是晚上思考人生+平复心态 改题都不怎么想改… dalao聊成绩的时候被各种暴踩 就当给自己锻炼心态了- - 以前打了那么久的LOL练的心态可不是白练的 只能祈求NOIP的数据水一点了 Day 4上午上文化, 中午依然来机房过快乐日子 这才听到他们说我们本校的毒瘤数据出了 每个人测了一遍 GC神仙430 orz 大着胆子看了一眼自己的成绩 90+100+55+84+15+0=344 ??????????????????????????????????????????????????????????????????? 这真的是毒瘤数据???? 但别人好像分数都挺正常的…唯独我的拉上去了70分 虽然知道344是不可能的, 但是好歹还是让我心态略微平复了一点 笑容渐渐恢复 Day 6学军的数据来了. 果然很毒瘤, 我一落千丈: 70+80+40+68+15+0=273 跟最低预估分差不多了. 不过还好吧, 毕竟现在我的分数范围变成了273-344了- - 希望NOIP给个救命分吧2333 中午顺便改了改简单的题 D1T1T2, D2T1都改了 Day 10听说今天早上成绩会出. 10:00大课间匆匆跑过来 成绩单未上传, 请稍后查看! 还是等明天吧… Day 11早上7:00, 我爸就打电话过来说出了. 我发了账号密码过去叫他帮我查. 7:30左右他回了电话过来 当时我还在食堂为作业写不完发愁 319. NOIP还是挺给面子的. 后来查到如文章开头所示的各题得分, 让我惊讶的一点是D1T2NOIP的数据20分都放过去了, 挺良心的- - 还有D2T1错解得了个84, 正常得分应该是72的233 尾声仔细想想, 还是自己基础不够扎实, 也有一些心态上的问题, 导致了联赛考的如此之差. 就比如D1T2, 要不是lzhdalao说”这题比砝码称重不知道简单到哪里去了”, 我都根本想不起来我做过砝码称重这道题. 要是当时能想起来, D1T2应该是可以10min切掉的. T1就不说了… 自己过分自大看不起普及-, 但就是这题我想不出来. (数据范围放了 $O(n\text{log}n)$ 过去, 但我也没打) T3的话, 如果能在1h内搞完T1和T2, 用两个半小时我应该还是能想出来的 D2的话 T1错在没认真读题 (小插曲: 当时我改题的时候下了一波洛咕的数据, 看完输入输出后还以为洛咕数据是错的- -打算投诉的时候csydalao闻讯赶来, 嘲讽了我一波, 我那时候才知道理解错了) T2的话就随缘了… $n \le 2$ 时间给多应该可以推出来 T3就不说了 那44分的教训可以让我铭记一生 恬不知耻的算了一下最高得分: 100+100+55+100+50+44=449, 这也就是现阶段的我状态最好最好最好下能拿到的分数了(然而 $tan\ \frac{k\pi}{2},k \in Z$) 强行苟在组里没有退役, 这次的教训已经够惨重了, 加油吧. 也有一些朋友退役了… 衷心的祝愿文化课快乐. Update in 12.4HN的分数线是305. 虽然我知道今年分数线放了很多水, 省一并不值钱, 但是听到消息的时候还是很高兴的. 为csy的302默哀… 接下来的一年, 尽管莽吧 Thanks for your reading.]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2FHello-World.html</url>
    <content type="text"><![CDATA[$\text{Welcome to my blog!}$折腾了好久 终于搭好了2333 用于记录自己的各类经历- - 1234#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl; &#125;]]></content>
      <categories>
        <category>感想</category>
      </categories>
  </entry>
</search>
